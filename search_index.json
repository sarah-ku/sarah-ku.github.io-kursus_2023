[["index.html", "Analyse og visualisering af biologiske datasæt - 2023 Chapter 1 Grundlæggende R 1.1 Inledning til kapitel 1.2 RStudio 1.3 Working directory 1.4 R pakker 1.5 Hvor kommer vores data fra? 1.6 Beregninger i R 1.7 Dataframes 1.8 If/else 1.9 Loops 1.10 Descriptive statistics 1.11 Statistike tester 1.12 Problemstillinger", " Analyse og visualisering af biologiske datasæt - 2023 Sarah Rennie Last updated: 2023-05-08 Chapter 1 Grundlæggende R “Det er ikke, fordi noget er svært, at vi ikke tør, det er, fordi vi ikke tør, at noget er svært” - Seneca 1.1 Inledning til kapitel Først og fremmest, velkommen til kurset! Det her dokument er kursusnotaterne, som indeholder bla. videoer, forklaringer og problemstillinger, og jeg opdaterer dem løbende gennem hele forløbet. Vær opmærksom på, at der også vil være flere dokumenter på Absalon vedrørende forelæsninger, workshops og løsningerne til øvelserne. I dette kapitel opsummerer jeg nogle grundlæggende elementer inden for R og statistik, der betragtes som forudsætninger i dette kursus. Selvom vi i kurset skifter hurtigt over til tidyverse-pakken, som erstatter en stor del af funktionaliteten fra base-R, er det stadig vigtigt at have et grundlæggende kendskab til hvordan tingene fungerer i base-R. Hvis du har begrænset erfaring med base-R, anbefaler jeg, at du bruger ekstra tid ud over de første mødegange for at nå det nødvendige niveau. For at bestå kurset forventes det ikke, at du kender til alle detaljer og teorier bag de statistiske metoder, men at du kan anvende dem hensigtsmæssigt i praksis i R og fortolke resultaterne korrekte. Der vil være masser af muligheder for at øve dig I at anvende statistik hele vejen gennem kurset, og under eksamen vil jeg ikke stille spørgsmål om metoder, der ikke er dækket i de forskellige øvelser (herunder workshop-opgaver). Lineær regression vil også blive gennemgået i forelæsningerne så vær ikke bekymret hvis du ikke har set det hele før. Se gerne også “Quiz - grundlæggende” på Absalon for at tjekke din forståelse og udfylde eventuelle huller i din viden (OBS: Quizzen er tilgængelig kort tid inden kursets start). 1.2 RStudio Vi kommer fremadrettet til at være afhængig af RStudio til at arbejde med bl.a. R Markdown dokumenter. Kendskab til R Markdown er emnet i vores næste lektion og jeg går ud fra, at du ikke har benyttet det før. Det allerførste du bør gør, hvis du ikke har installeret RStudio på din computer, er at downloade det gratis på nettet: https://www.rstudio.com/products/rstudio/download/#download Følg venligst RStudios egne anvisninger til at få det installeret. Bemærk, at installering af RStudio er ikke den samme som at have R installeret på din computer - man skal installere dem begge to (man kan bruge R uden RStudio men ikke omvendt. 1.2.1 De forskellige vinduer i RStudio Du kan læse følgende for at lære de fire forskellige vinduer i RStudio at kende: https://bookdown.org/ndphillips/YaRrr/the-four-rstudio-windows.html Her er et kort oversigt: Man skriver kode i Source (øverst til venstre) Man kører kode ved at tryk CMD+ENTER (eller WIN-KEY+ENTER) Koder køres ind i Console (som plejer at være nederst til venstre, selvom det er øverst til højere i billedet). Man kan også skrive koder direkte i Console, men det ikke anbefales generelt, når koden ikke bliver gemt. Environment - her kan man se blandt andet, alle objekter i Workspace. 1.3 Working directory Når man arbejder på et projekt, er det ofte nyttigt at vide, den working directory som R arbejder fra - det er den mappe, hvor R forsøger at åbne eller gemme filer fra, medmindre man angiver et andet sted. getwd() #se nuværende working directory list.dirs(path = &quot;.&quot;, recursive = FALSE) #se mappe indenfor working directory setwd(&quot;~/Documents/&quot;) #sætte en ny working directory (C:/Users/myname/Documents hvis man bruger Windows) Hvis man bruger Windows, husk at man kan skrive en path på følgende måde: #notrun setwd(&quot;C:/Users/myname/Documents&quot;) #enten med / setwd(&quot;C:\\\\Users\\\\myname\\\\Documents&quot;) #eller med \\\\ OBS: jeg bruger Mac, så hvis der er et vigtigt ting at man skal huske hvis man bruger en Windows computer, kan jeg også tilføje det her. Bemærk dog, at de allerfleste ting ved R programmering og tidyverse er ens uanset om man bruger Windows eller Mac. 1.4 R pakker R pakker er simpelthen en samling af funktioner (eller datasæt i nogle tilfælde), der udvider, hvad er tilgængelige i base-R (den R man få, uden at indlæse en pakke). I R er der mange tusind R pakker (op mod 100,000), der er tilgængelige på CRAN (https://cran.r-project.org/). Indenfor det biologiske fag er der også mange flere pakker på Bioconductor (https://www.bioconductor.org/), og i nogle tilfælde kan R pakker også installeres direkte fra Github. I dette kursus arbejder vi rigtig meget med en pakke der hedder tidyverse. tidyverse er faktisk en samling af otte R pakker, som indlæses på en gang. Inden du indlæse pakken, skal du først sikre dig, at pakken er installeret på systemet ved følgende kommando: install.packages(&quot;tidyverse&quot;) Alle pakker på CRAN er installeret på samme måde. Når du faktisk gerne vil bruge en R pakke, skal du først indlæse den ved at bruge library(): library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.0 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.1 ✔ tibble 3.1.8 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors Vi kommer til at arbejde med tidyverse pakker fra kapitel tre (vi starter med ggplot2 og så nogle af de andre pakke fra tidyverse fra kapitel fire), så det er en god idé at har tidyverse installeret allerede nu, når det nogle gange kan tage lidt tid til at installere eller opdatere de mange andre mulige pakker, der tidyverse er afhængig af. Vær opmærksom på, at der nogle gange opstår konflikter når det samme funktionnavn findes i flere pakker - for eksempel, funktionen filter() findes indenfor to forskellige pakker, nemlig dplyr og stats. Når du skriver filter() så ved R ikke, hvilke pakker du mener. I dette tilfælde kan du være gennemskueligt overfor den pakke, du gerne vil bruge ved at skrive dplyr::filter() eller stats:filter() i stedet for bare filter(). Som sidste kommentar, er det god praksis at indlæse alle pakker, der du benytter sig af, på toppen af din script, så at du hurtigt kan få overblik over, hvilke pakker, der skal indlæses til at få dine koder til at fungere. 1.5 Hvor kommer vores data fra? De forskellige datasæt, vi kommer til at arbejde med i kurset stammer fra mange forskellige steder. 1.5.1 Indbyggede datasæt I R er der mange indbygget datasæt som er meget brugbart for at vise koncepter, hvilket gøre dem især populært i undervisningsmateriale. Indbyggede datasæt er ofte tilgængligt indenfor mange pakker, men library(datasets) er den mest brugt (der er også mange indenfor library(ggplot2). For eksempel, for at indlæse datasættet, der hedder ‘iris’, kan man bruge data(): library(datasets) data(iris) Så er en dataframe, der hedder ‘iris’ tilgængelige som en objekt i workspacen - se den “Environment” fane på højere side i RStudio, eller indtaste ls(), så bør du kunne se et objekt med navnet ‘iris’. Man kan kun arbejde med objekter som er en del af workspacen. 1.5.2 Importering af data fra .txt fil Det er meget hyppigt, at man har sin data i formen af en .txt fil eller .xlsx fil på sin computer. Den nemmeste måde at få åbnet en .txt fil er ved at bruge read.table(), som i nedenstående: data &lt;- read.table(&quot;mydata.txt&quot;) #indlæse data filen mydata.txt som er i working directory head(data) Hvis datasættet har kolonner navne, der er skrevet ind i filen, så skal man huske at bruge header=T for at undgå, at den første række i datasættet bliver disse tekste i stedet for virkelige observationer. data &lt;- read.table(&quot;mydata.txt&quot;,header=T) #indlæse data filen mydata.txt som er i working directory head(data) 1.5.3 Importering af data fra Excel Der findes også en hjælpsom pakke, som hedder readxl, der kan indlæse Excel-ark direkte ind i R: library(readxl) data &lt;- read_excel(&quot;data.xlsx&quot;) data 1.5.4 Kaggle Hvis du gerne vil øve dig med statistike analyser (udover nuværende kursus), er Kaggle en fantastisk ressource til at finde forskellige datasæt. I rigtige mange tilfælde kan man også finde analyser some andre har lavet I R (også Python), hvilket kan inspirere jeres egen læring. Link hvis interesseret: https://www.kaggle.com/ 1.6 Beregninger i R Her er nogle helt grundlæggende koncepter når man arbejder med R. Du må selvfølgelige gerne springe sektionen over, hvis du allerede har meget erfaring med base R, men det kan være værd at tjekke, om der noget ting, der lige skal gennemgås. En god tilgang er bare at arbejde gennem problemstillingerne nedenfor, og bruger følgende notater som en reference. 1.6.1 Vectorer I R laver man en vector med c(), hvor man adskiller de forskellige elementer med en komma, som i nedenstående eksempel: a &lt;- c(1,2,3,4,5) #sæt objektet &#39;a&#39; til at være en vector af tal a ## [1] 1 2 3 4 5 Man er ikke begrænset til tal: c &lt;- c(&quot;cat&quot;,&quot;mouse&quot;,&quot;horse&quot;,&quot;sheep&quot;,&quot;dog&quot;) c ## [1] &quot;cat&quot; &quot;mouse&quot; &quot;horse&quot; &quot;sheep&quot; &quot;dog&quot; 1.6.2 datatyper Nar vi kommer til at arbejde med visualiseringer og data beardejdning er det vigtigt at have styr på datatyper i datasættet. For eksempel har vectoren c ovenpå typen character (forkortet chr) og ikke numeric (forkortet num): is.numeric(c) ## [1] FALSE is.character(c) ## [1] TRUE Her er en list overfor nogle af de vigtigste datatyper: Datatype Navn Beskrivelse int integer kun hel tal c(-1,0,1,2,3) lgl logical TRUE TRUE FALSE TRUE FALSE chr character c(\"Bob\",\"Sally\",\"Brian\",...) fct factor bestemte niveauer e.g. Species: c(\"setosa\",\"versicola\") dbl double Tal fk. c(4.3902, 3.12, 4.5) lst list blande forskellige data typer og specificere elementer med [[i]] [[1]] [1] c(\"red\",\"blue\") [[2]] [1] TRUE [[3]] [1] c(3,2.3,1.459) En datatype, der bør få særlig opmærksomhed er fct (factor). I følgende vector tea_coffee har vi tekst, men blandt de fem elementer er der kun to bestemte niveauer (nemlig “tea” og “coffee”). tea_coffee &lt;- c(&quot;tea&quot;,&quot;tea&quot;,&quot;coffee&quot;,&quot;coffee&quot;,&quot;tea&quot;) is.factor(tea_coffee) ## [1] FALSE tea_coffee ## [1] &quot;tea&quot; &quot;tea&quot; &quot;coffee&quot; &quot;coffee&quot; &quot;tea&quot; Vi vil derfor gerne fortælle R, at tea_coffee er ikke bare nogle tilfældig tekst men at der er en struktur med, så vi bruger funktionen as.factor for at lave den om til datatypen fct. tea_coffee &lt;- as.factor(tea_coffee) is.factor(tea_coffee) ## [1] TRUE tea_coffee ## [1] tea tea coffee coffee tea ## Levels: coffee tea Den ‘ekstra’ oplysninger man har ved at sige, at en variabel betragtes som factor bliver vigtigt når man arbejder med visualiseringer - for eksempel, hvis vi gerne vil lave et barplot hvor man gerne vil adskille søjlerne efter de to niveauer “tea” og “coffee” (visualiseringer er emnet fra kapitel 3). 1.7 Dataframes http://www.r-tutor.com/r-introduction/data-frame Mange af de ting, som vi laver i R tager udgangspunkten i dataframes (eller datarammer). mydf &lt;- data.frame(&quot;personID&quot;=1:5, &quot;height&quot;=c(140,187,154,132,165), &quot;age&quot;=c(34,31,25,43,29)) mydf ## personID height age ## 1 1 140 34 ## 2 2 187 31 ## 3 3 154 25 ## 4 4 132 43 ## 5 5 165 29 Man kan fa adgang til variabler i en dataframe ved at bruge det dollar tegn $. For eksempel giver følgende variablen personID fra dataframen mydf: mydf$personID ## [1] 1 2 3 4 5 Husk, at vores dataframe, ligesom et matrix (i R: matrix()) har to dimensioner - række og kolonner Forskellen mellem en matrix og en dataramme er, at datarammer kan indeholde mange forskellige data typer (herunder numeriske, faktorer, karakterer osv.), men matrix indeholder kun numeriske data. For eksempel i tilfældet af ovenstående dataframen er alle variabler numeriske, men vi kan godt tilføje en variabel som er ikke-numeriske: mydf$colour &lt;- c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;orange&quot;,&quot;purple&quot;) #make new variable which is non-numeric mydf ## personID height age colour ## 1 1 140 34 red ## 2 2 187 31 blue ## 3 3 154 25 green ## 4 4 132 43 orange ## 5 5 165 29 purple Nu er mydf er en dataframe, der blander forskellige datatyper, men følgende er en matrix matrix(c(1, 2, 3, 4, 5, 6), nrow=3, ncol=2) ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 og kan kun indeholde numeriske data, som kan bruges til at lave matematik operationer (matrix multiplikation osv.). I dette kursus beskæftiger os primært med dataframes (som bliver kaldt for tibbles i tidyverse). 1.7.1 Delmængder af dataframes Selvom vi kommer til at redefinere hvordan man laver delmængde når vi kommer til at arbejde med pakken tidyverse, er det alligevel vigtigt at forstå, hvordan man laver en delmængde i base-R, og det er et område, der ofte skaber forvirring blandt de uerfarne. Når man vil gerne har en bestemt delmængde af en vector, bruger man firkantet paranteser [ ]. Følgende kode giver mig de første to værdier fra vectoren a: a[1:2] ## [1] 1 2 Bemærk, at mens vectorer har kun en dimension, har dataframes to dimensioner. Når man skal lave en delmægde af en dataframe, skal man derfor fortælle R, hvilke række og hvilke kolonner skal være med. mydf[række indekser, kolonner indekser] #not run For eksempel, hvis vi gerne vil have de første to observationer med, samt kun den anden variabel, skriver man følgende: mydf[1:2, 2] #first two rows (observations), second column (variable) only ## [1] 140 187 Hvis vi vil beholde den første to observationer og samtlige variabler, kan den anden plads være tom: mydf[1:2, ] #first two rows, all columns ## personID height age colour ## 1 1 140 34 red ## 2 2 187 31 blue Jeg kan også angive et variabelnavn direkte: mydf[1:2,&quot;height&quot;] ## [1] 140 187 Man kan kigge på en subset af rækkerne i de data ved at mydf[mydf$height&gt;=165,] #alle rækker i datarammen med height = 165 eller over ## personID height age colour ## 2 2 187 31 blue ## 5 5 165 29 purple Her er en tabel af comparitiver, og jeg gengiver samme tabel når I kommer til at lave delmængde i tidyverse: comparitiv beskrivelse &lt; less than &gt; greater than &lt;= less than or equal to &gt;= greater than or equal to == equal to != not equal to &amp; and %in% in | or ! not Jeg mener, at %in% er særlig brugbart og er værd at lære: mydf[mydf$personID %in% c(1,3,5),] #alle personer med personID 1,3 eller 5 ## personID height age colour ## 1 1 140 34 red ## 3 3 154 25 green ## 5 5 165 29 purple Her er et eksempel på, hvordan man bruger udråbstegnet: personer med personID, der ikke er 1,3 eller 5: mydf[!(mydf$personID %in% c(1,3,5)),] #alle personer med personID 2 eller 4 ## personID height age colour ## 2 2 187 31 blue ## 4 4 132 43 orange 1.8 If/else If/else kodekonstruktioner giver mulighed for at udføre forskellige handlinger baseret på, om en bestemt betingelse er opfyldt. Her er et eksempel med if med betingelsen number &gt; 0: number &lt;- 42 if (number &gt; 0) { print(&quot;Number is positive&quot;) } ## [1] &quot;Number is positive&quot; Hvis betingelse er sand udføres den handling indenfor { }, dvs. “Number is positive” printes. If/else konstruktioner gør det samme, men hvis betingelsen er falsk, udføres en alternativ handling: number &lt;- -5 if (number &gt; 0) { print(&quot;Number is positive&quot;) } else { print(&quot;Number is not positive&quot;) } ## [1] &quot;Number is not positive&quot; Man kan også opnå samme resultat med at bruge ifelse: number &lt;- 3 numbers_of_interest &lt;- c(1,3,5,7) ifelse(test = number %in% numbers_of_interest, yes = &quot;Number is interesting&quot;, no = &quot;Number is uninteresting&quot;) ## [1] &quot;Number is interesting&quot; Man behøver ikke at skrive ordene “test”, “yes” og “no” hver gang, såfremt at du bruger samme rækkefølgen som funktionen forventer: ifelse(number %in% numbers_of_interest, &quot;Number is interesting&quot;, &quot;Number is uninteresting&quot;) ## [1] &quot;Number is interesting&quot; 1.9 Loops I base-R kan man laver simpel loops med følgende konstruktion: for (i in 1:5) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Loops bliver et stort emne senere i kurset (emne 8/9). 1.10 Descriptive statistics 1.10.1 Simulere data fra den normale fordeling Hvis du har bruge for at vide mere om den normale fordeling: http://www.r-tutor.com/elementary-statistics/probability-distributions/normal-distribution Man kan nemt lave sin egne ‘fake’ data ved at simulere det fra en fordeling, der typisk er normalfordelingen, da den er den mest almindelige fordeling i den virkelige verden (husk den klassiske klokkeform). I R kan funktionen rnorm bruges til at simulere data. Først angiver man antallet af observationer, og derefter den gennemsnitlige værdi og standardafvigelsen (sd), som er de to nødvendige parametre for at beskrive en normalfordeling. x &lt;- rnorm(25,mean=0,sd=1) #standard normal distribution x #så har vi 25 værdier fra en normal distribution med mean=0 og standard deviation=1. ## [1] 0.60806862 0.84484931 -1.85992169 0.23377315 -0.31795058 -0.76914778 ## [7] -1.15966148 0.46178614 -0.09588612 1.30957822 0.81428767 1.45968595 ## [13] 1.59263683 0.38980486 0.29886733 0.35599064 -0.70605172 -1.42373782 ## [19] 0.67574226 0.86746846 0.85616018 0.06551859 1.00136514 -0.04394735 ## [25] -3.44658162 I stedet for at kigge på alle værdier på én gang, vil vi måske hellere kigge kun på de første (eller sidste) værdier: head(x) #første 6 ## [1] 0.6080686 0.8448493 -1.8599217 0.2337732 -0.3179506 -0.7691478 tail(x) #sidste 6 ## [1] 0.86746846 0.85616018 0.06551859 1.00136514 -0.04394735 -3.44658162 x[1] #første værdi ## [1] 0.6080686 x[length(x)] #sidste data point ## [1] -3.446582 Bemærk, at i modsætning til Python og mange andre programmeringssprog, bruger R en 1-baseret indeksering. Det betyder, at den første værdi er x[1] og ikke x[0] som i Python. 1.10.2 Measures of central tendency function Description mean() mean \\(\\bar{x}_{i} = \\frac{1}{n}\\sum_{i=1}^{n} x_{i}\\) median() median value max() maximum value min() minimum value var() variance \\(s^2 = \\frac{1}{n-1}\\sum_{i=1}^{n} (x_{i} - \\bar{x}_{i})^2\\) sd() standard deviation \\(s\\) Lad os afprøve dem på vores simulerede data: my_mean &lt;- mean(x) my_median &lt;- median(x) my_max &lt;- max(x) my_min &lt;- min(x) my_var &lt;- var(x) my_sd &lt;- sd(x) c(my_mean,my_median,my_max,my_min,my_var,my_sd) #print results ## [1] 0.08050789 0.35599064 1.59263683 -3.44658162 1.31100696 1.14499212 Man kan også lave et summary af dataen, som består af mange af de statistiker navnt ovenpå: summary(x) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -3.44658 -0.31795 0.35599 0.08051 0.84485 1.59264 1.10.3 tapply() tapply() er en meget nyttig funktion i R, som kan bruges til at anvende en funktion på en gruppe af data baseret på værdier i en anden vektor. Funktionen tager tre hovedargumenter: den vektor, som vi ønsker at anvende funktionen på, den vektor, som bruges til at gruppere dataene, og funktionen, som vi ønsker at anvende på hver gruppe. tapply() vil derefter opdele dataene i grupper baseret på den anden vektor og anvende funktionen på hver gruppe. Resultatet af tapply() vil være en vektor, som indeholder resultaterne af funktionen anvendt på hver gruppe af data. For eksempel: data(iris) tapply(iris$Sepal.Length,iris$Species,mean) # ovenstående i kun en linje ## setosa versicolor virginica ## 5.006 5.936 6.588 Her tager vi en vektor ved navn Sepal.Length, opdeler den efter Species og beregner gennemsnittet ved hjælp af funktionen mean for hver af de tre arter i Species (setosa, versicolor og virginica). Alternativt kunne man have beregnet gennemsnittet for hver af de tre Species separat (en tilgang, der ikke skalerer godt!): # gennemsnit Sepal Length for Species setosa mean_setosa &lt;- mean(iris$Sepal.Length[iris$Species==&quot;setosa&quot;]) # gennemsnit Sepal Length for Species versicolor mean_versi &lt;- mean(iris$Sepal.Length[iris$Species==&quot;versicolor&quot;]) # gennemsnit Sepal Length for Species virginica mean_virgin &lt;- mean(iris$Sepal.Length[iris$Species==&quot;virginica&quot;]) c(mean_setosa,mean_versi,mean_virgin) ## [1] 5.006 5.936 6.588 Det er også værd at ved koncepten, fordi vi kommer til lære en lignende koncept i tidyverse (med group_by og summarise). 1.11 Statistike tester Her er en oversigt over nogle af de mest grundlæggende tests, som man kan udføre på data i R. Det kan være nyttigt som en reference senere hen, hvis det er nødvendigt. Jeg vil ikke gå i dybden med teorien bag disse tests (da det antages, at du har lært det tidligere), men jeg forventer, at du er i stand til at anvende dem korrekt i R og fortolke resultaterne. Hvis du ikke er bekendt med nogle af disse tests, vil der være masser af muligheder for at øve dig i statistik gennem kurset. t-test: Bruges til at sammenligne to grupper og afgøre, om forskellen mellem deres gennemsnitlige værdier er statistisk signifikant. ANOVA: Bruges til at sammenligne mere end to grupper og afgøre, om der er statistisk signifikant forskel mellem mindst to af grupperne. Korrelationsanalyse: Bruges til at afgøre, om der er en statistisk signifikant sammenhæng mellem to variabler. Regressionsanalyse: Bruges til at afgøre, om der er en statistisk signifikant sammenhæng mellem en uafhængig variabel og en afhængig variabel og at forudsige værdien af den afhængige variabel baseret på værdien af den uafhængige variabel. Chi-square test: Bruges til at afgøre, om der er en statistisk signifikant forskel mellem observerede og forventede værdier for kategoriske variabler. 1.11.1 P-værdien Først og fremmest er det vigtigt at kunne huske p-værdi både i forhold til definitionen og i forhold til hvordan det fortolkes. P-værdien er sandsynligheden for at observere et resultat lige så ekstremt eller mere ekstremt end det observerede, givet at null-hypotesen er sand. Null-hypotesen er en antagelse om, at der ikke er nogen signifikant forskel mellem grupper eller variabler i det dataset, som der arbejdes med. Hvis p-værdien er mindre end det valgte signifikansniveau (typisk 0,05), så betyder det, at det observerede resultat er usandsynligt at opstå ved ren tilfældighed, og null-hypotesen forkastes til fordel for den alternative hypotese om, at der er en signifikant forskel mellem grupper eller variabler i datasættet. 1.11.2 Korrelation Korrelation måler styrken og retningen af den lineære sammenhæng mellem to kontinuerte variabler, som begge er normalfordelte: \\(&gt;0\\) betyder, at der er en positiv sammenhæng \\(&lt;0\\) betyder, at der er en negativ sammenhæng \\(=0\\) betyder, at der er ingen sammenhængen mellem de to variabler data(cars) cor(cars$speed, cars$dist) ## [1] 0.8068949 Husk dog, at “Correlation does not equal causation” - dvs. at korrelation er bare en sammenhæng og ikke nødvendigvis angiver en årsagssammenhæng mellem de to variable. Funktionen cor.test() kan bruges til at teste, om korrelationen mellem to variable er statistisk signifikant. Null-hypotesen antager, at der ikke er nogen korrelation mellem de to variable i den population, som datasættet repræsenterer. cor.test(cars$speed, cars$dist) ## ## Pearson&#39;s product-moment correlation ## ## data: cars$speed and cars$dist ## t = 9.464, df = 48, p-value = 1.49e-12 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.6816422 0.8862036 ## sample estimates: ## cor ## 0.8068949 Så kan man se, at p-værdien er 0, der er under 0.05. Derfor konkluderer man, at der er en signifikant sammenhæng mellem de to variabler. 1.11.3 Test for uafhængighed (chi-sq test) En chi-squared test kan bruges til at undersøge, om der er en statistisk signifikant sammenhæng mellem antallet af observationer i to eller flere forskellige kategorier. For eksempel kan man teste for sammenhængen mellem antallet af kopier af en genvariant og to forskellige farver på blomster i en bestemt planteart. 0 1 2 red 29 31 16 pink 11 16 24 Vi vil gerne vide, om phenotype er afhængig af genotype: \\(H_{0}:\\) antal gen copi og phenotype er uafhængie af hinanden VS \\(H_{1}:\\) antal gen copi og phenotype er afhængie af hinanden Testen går ud på, at man beregner forventede værdier under nulhypotesen om, at der ikke er nogen sammenhæng mellem de to kategorier, og sammenligner disse forventede værdier med observerede værdier. Man laver testen i R ved at benytte funktionen chisq.test(): chisq.test(dat) ## ## Pearson&#39;s Chi-squared test ## ## data: dat ## X-squared = 9.9516, df = 2, p-value = 0.006903 Her er p-værdien = 0.006903 &lt; 0.05, så vi forkaster nulhypotesen og konkluderer, at der er en signifikant sammenhæng mellem de to variabler. Ud fra rådatasættet kan man også observere, at der er flere røde blomster uden nogen kopi af genet sammenlignet med røde blomster med to kopier af genet, mens det modsatte er tilfældet for de lyserøde blomster. 1.11.4 1 sample t-test For at vise en 1-sample t-test, simulerer jeg nogle data fra en normalfordeling med middelværdi på 3 ved hjælp af rnorm()-funktionen: set.seed(290223) # bare for at få den samme resultat hver gang x &lt;- rnorm(10,mean = 3,sd = 1) Forestil dig, at du ikke helt stoler på funktionen rnorm() og ønsker at teste, om x stammer fra en normalfordeling med en middelværdi på 3. Nulhypotesen og den alternative hypotese (to-sidet test) er derfor: \\(H_{0}: \\mu = 3\\), VS \\(H_{1}: \\mu \\neq 3\\) For at lave testen i R, bruger man funktionen t.test() og angiver mu = 3 for at reflektere vores hypoteser: t.test(x,mu = 3) ## ## One Sample t-test ## ## data: x ## t = -1.1448, df = 9, p-value = 0.2818 ## alternative hypothesis: true mean is not equal to 3 ## 95 percent confidence interval: ## 2.169968 3.272231 ## sample estimates: ## mean of x ## 2.721099 Fra resultatet kan man se, at p-værdien er estimeret til 0.2818, og da den er &gt; 0.05 kan vi ikke forkaste nulhypotesen, og vi konkluderer derfor, at middelværdien af x ikke adskiller sig signifikant fra 3. Bemærkning: da vi simulerede vores data fra en normal fordeling med et gennemsnit på tre, vidste vi i forvejen at det korrekte svar er, at beholde nullhypotesen. Havde vi forkastet nullhypotesen, havde vi lavet en type I fejl - det vil sige, at vi forkaster nullhypotesen når det faktisk er sandt. 1.11.5 2-sample t-test Undersøger om der er en forskel i de gennemsnitlige værdier mellem to grupper - kan de to grupper betragtes til at stammer fra den samme normale fordeling? Hypoteserne er således (to-sidet): \\(H_{0}: \\mu_{1} = \\mu_{2}\\), VS \\(H_{1}: \\mu_{1} \\neq \\mu_{2}\\) I følgende kode simulere jeg to stikprøver, der kommer fra en normal fordeling med forskellige gennemsnitte og bruger funktionen t.test. Man kan angive at de to stikprøver har samme variance ved at skrive var.equal = T indenfor funktionen t.test: x &lt;- rnorm(10,3,1) y &lt;- rnorm(10,5,1) t.test(x,y,var.equal = T) ## ## Two Sample t-test ## ## data: x and y ## t = -5.4258, df = 18, p-value = 3.729e-05 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -2.700858 -1.193081 ## sample estimates: ## mean of x mean of y ## 2.783056 4.730025 Hvis man til gengæld ikke kan antage, at variansen er den samme i de to grupper: x &lt;- rnorm(10,3,1) y &lt;- rnorm(10,5,3) #større variance t.test(x,y,var.equal = F) #var.equal=F er &#39;default&#39; så man behøver ikke at specifere ## ## Welch Two Sample t-test ## ## data: x and y ## t = -2.0238, df = 11.77, p-value = 0.0663 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -3.9077927 0.1483728 ## sample estimates: ## mean of x mean of y ## 2.757436 4.637146 Bemærk at hvis man kan antage at variancen er den samme, så har man mere power (kræft) til at kalde en virkelig forskel for signifikant. 1.11.6 Paired t-test En paired t-test bruges når man for eksempel har målinger for den samme sæt personer i hver stikprøve, og man gerne vil teste om forskellen i værdier mellem de to stikprøver er signifikant. For eksempel hvis vi har “before” og “after” målinger for den samme 10 individer: set.seed(320) before &lt;- rnorm(10,3,1) after &lt;- rnorm(10,6,2) t.test(before,after,paired=T) #specificy paired data ## ## Paired t-test ## ## data: before and after ## t = -9.3296, df = 9, p-value = 6.356e-06 ## alternative hypothesis: true mean difference is not equal to 0 ## 95 percent confidence interval: ## -5.415186 -3.301613 ## sample estimates: ## mean difference ## -4.358399 t.test(before-after,mu=0) #exactly the same result ## ## One Sample t-test ## ## data: before - after ## t = -9.3296, df = 9, p-value = 6.356e-06 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## -5.415186 -3.301613 ## sample estimates: ## mean of x ## -4.358399 1.11.7 ANOVA (variansanalyse) Har man flere grupper i stedet for to, kan man bruge ANOVA (analysis of variance eller variansanalyse). For en kategorisk variabel med \\(k\\) grupper, er nul/alternativhypotesen: \\(H_{0}: \\mu_{1} = \\mu_{2} = \\ldots = \\mu_{k}\\) \\(H_{1}:\\) ikke alle middelværdier er enes #simulere data til 3 forskellige grupper fra den normale fordeling med standard afvigelse af 3 group1 &lt;- rnorm(50,10,3) group2 &lt;- rnorm(55,10,3) group3 &lt;- rnorm(48,5,3) #data må være i en dataramme, med den ene kolon = vores værdier, og den anden kolon = grupper y &lt;- c(group1,group2,group3) x &lt;- c(rep(&quot;G1&quot;,50),rep(&quot;G2&quot;,55),rep(&quot;G3&quot;,48)) mydf &lt;- data.frame(&quot;group&quot;=x,&quot;value&quot;=y) For at udføre testen kan man bruge funktionen lm(), som står for “linear model” og kan bruges til at opbygge forskellige modeller. Her angiver vi en model, hvor hver gruppe (G1, G2 og G3 fra variablen x) har sin egen middelværdi (variablen value), hvilket er modellen under alternativhypotesen: mylm &lt;- lm(value~group,data=mydf) #H1 model Under nulhypotesen har alle grupper den samme middelværdi, og derfor behøver vi ikke at inkludere variablen group i modellen. Vi angiver situationen i modellen ved at skrive 1, som betyder, at forventede værdier for den afhængige variabel value blot er dens middelværdi: mylm_null &lt;- lm(value~1,data=mydf) #H0 model For at sammenligne de to modeller benytter vi funktionen anova() (efter analysis of variance): anova(mylm_null,mylm) ## Analysis of Variance Table ## ## Model 1: value ~ 1 ## Model 2: value ~ group ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 152 2215.4 ## 2 150 1509.9 2 705.55 35.047 3.245e-13 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 P-værdien er (&lt;0.05), så nulhypotesen er forkastet til fordel af alternativhypotesen, altså modellen, hvor hver gruppe har sin egen middelværdi. Bemærk at det er til trods af, at to af de tre grupper kommer fra en normal fordeling med præcis de samme middelværdier (det er nok, at den trejde gruppe har en ænderledes middelværdi). 1.11.8 Lineær regression OBS: se også video i forbindelse med Rmarkdown (næste emne), hvor jeg gennemgå lineær regression med R Formål: måler (en retningsbestemt) relation mellem to kontinuerte variabler. I simpel lineær regression svarer det til, at man gerne vil finde den rette linje gennem punkterne, der bedste beskriver relationen. Eksempel - datasættet mtcars, response (afgængig) variabel er mpg og predictor (uafhængig) variabel er wt. Man skriver relationen i R som mpg ~ wt og benytter lm()(lm(mpg~wt,data=mtcars)): mylm &lt;- lm(mpg ~ wt, data=mtcars) # build linear regression model mylm ## ## Call: ## lm(formula = mpg ~ wt, data = mtcars) ## ## Coefficients: ## (Intercept) wt ## 37.285 -5.344 Vores “Coefficients” beskriver den bedste rette linje: Skæringen (intercept): 37.285 Hældningskoefficient (slope): -5.344 Det betyder, at hvis vægten wt af en bil stiger med 1, så stiger mpg ved -5.344 (det vil sige at mpg reduceres med 5.344). 1.11.9 R-squared coefficient of determination Den \\(R^2\\) eller “forklaringsgraden” (coefficeint of determination) har til formål at forklare, hvor godt vores lineær model passer til de data. For eksempel hvor meget af variansen i mpg forklares af variablen wt? Hvis det er tæt på 1 - så er der en meget tæt relation (hvis man kender vægten, så vide man også mpg med stor sikkerhed) Hvis det er tæt på 0 - så er relationen svag - høj sandsynlighed for, at der er andre variabler der bedre kan forklare variansen i mpg. I ovenstående model, kan man se den \\(R^2\\) værdi med summary(mylm). summary(mylm) ## ## Call: ## lm(formula = mpg ~ wt, data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.5432 -2.3647 -0.1252 1.4096 6.8727 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 37.2851 1.8776 19.858 &lt; 2e-16 *** ## wt -5.3445 0.5591 -9.559 1.29e-10 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.046 on 30 degrees of freedom ## Multiple R-squared: 0.7528, Adjusted R-squared: 0.7446 ## F-statistic: 91.38 on 1 and 30 DF, p-value: 1.294e-10 Det fortæller os, at \\(R^2\\) = 0.7528. 1.11.10 Antagelser - lineær regression Normalfordelte residualer Residualer har samme spredning (varianshomogenitet) Uafhængighed Fit er linæer Koden plot(mylm,which=c(1)) angiver residualer vs predikterede (fitted) værdier - de skal være tilfældigt fordelt over plottet og prikkernes varians skal være nogenlunde konstant langt x-aksen (det giver, at den røde linje er flade). plot(mylm,which=c(1)) Med koden plot(mylm,which=c(2)) kan man tjekke antagelsen på en normal fordeling. Punkterne skal være nogenlunde tæt på den diagonale linje. plot(mylm,which=c(2)) 1.11.11 Multiple lineær regression Her kan man tilføje flere variabler i vores model formel. mylm_disp &lt;- lm(mpg ~ wt + disp, data=mtcars) # build linear regression model summary(mylm_disp) ## ## Call: ## lm(formula = mpg ~ wt + disp, data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.4087 -2.3243 -0.7683 1.7721 6.3484 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 34.96055 2.16454 16.151 4.91e-16 *** ## wt -3.35082 1.16413 -2.878 0.00743 ** ## disp -0.01773 0.00919 -1.929 0.06362 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.917 on 29 degrees of freedom ## Multiple R-squared: 0.7809, Adjusted R-squared: 0.7658 ## F-statistic: 51.69 on 2 and 29 DF, p-value: 2.744e-10 Her kan man se, at med tilføjelsen af variablen disp, er \\(R^2\\) steget til 0.7809. Bemærk, at jo flere variabler man tilføjer til modellen, jo større bliver \\(R^2\\)-værdien. Den adjusted \\(R^2\\) værdi er lavere fordi den prøver at tage højde for kompleksiteten af modellen (hvor mange parametre der er). Variablen disp er faktisk ikke selv signifikant når der er taget højde for variablen wt (p-værdien 0.0636 - tjek, at du selv kan finde værdien i resultatet). Hvis en af de uafhængige variabler er kategorisk bruger man funktionen anova til at teste den overordnet effekt af den variabel. For eksempel har variablen cyl 3 mulige værdier (niveauer) - 4, 6 og 8. Vi kan inddrage variablen i vores model: –&gt; mylm_cyl &lt;- lm(mpg ~ wt + factor(cyl), data=mtcars) # build linear regression model summary(mylm_cyl) ## ## Call: ## lm(formula = mpg ~ wt + factor(cyl), data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.5890 -1.2357 -0.5159 1.3845 5.7915 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 33.9908 1.8878 18.006 &lt; 2e-16 *** ## wt -3.2056 0.7539 -4.252 0.000213 *** ## factor(cyl)6 -4.2556 1.3861 -3.070 0.004718 ** ## factor(cyl)8 -6.0709 1.6523 -3.674 0.000999 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.557 on 28 degrees of freedom ## Multiple R-squared: 0.8374, Adjusted R-squared: 0.82 ## F-statistic: 48.08 on 3 and 28 DF, p-value: 3.594e-11 Man kan ikke se den overordnet effekt af cyl fra den ovenstående summary men man kan teste den med anova: anova(mylm,mylm_cyl) ## Analysis of Variance Table ## ## Model 1: mpg ~ wt ## Model 2: mpg ~ wt + factor(cyl) ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 30 278.32 ## 2 28 183.06 2 95.263 7.2856 0.002835 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Så kan man se, at cyl er signifikant. 1.12 Problemstillinger Husk quizzen på Absalon, og lav gerne nogle øvelser for at øve dine færdigheder i R: Øvelse 2-8 er meget grundlæggende og i godt kan springes over, hvis man er nogenlunde fortrolig med base-R. Jeg vil anbefale øvelse 9-15 til alle som en god måde at teste deres viden på. Øvelse 16-20 fokuserer på andre statistiske test i R. Vi vil komme tilbage til regression flere gange i kurset, så det vil være en god idé at have kendskab til funktionen lm() til at opbygge modeller i ANOVA / simpel lineær regression (se også videoen og problemstillingerne til det næste emne R Markdown). 1.12.1 Quiz - Basics 1) Lav quiz i Absalon, der hedder “Quiz - Basics”. 1.12.2 Grundlæggende R 2) (helt baserende viden) Åbn en ny fil i RStudio ved at klikke på “File” &gt; “New File” &gt; “R Script”. Kør følgende kode en linje ad gangen og tjek, om du forstår outputtet. Husk, at den nemmeste måde at køre kode på er ved at trykke på CMD+ENTER (Mac) eller WIN-KEY+ENTER (Windows). 2+2 2*2 x &lt;- 4 x &lt;- x+2 sqrt(x) sqrt(x)^2 rnorm(10,2,2) log10(100) y &lt;- c(1,4,6,4,3) class(y) class(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) mean(y) sd(y) seq(1,13,by=3) 3) (helt baserende viden) Kør følgende kode til at åbne nogle af de indbygget datasæt, som vi bruger i kurset. * Prøve head(), nrow(), summary() osv. * Prøve også fk. ?cars for at se en beskrivelse. data(iris) data(cars) data(ToothGrowth) data(sleep) head(chickwts) data(trees) #se her for andre: library(help = &quot;datasets&quot;) 4) (baserende plots) Jeg giver nogle muligheder for datasættet “iris”. Prøv også at bruge nogle af de andre indbyggede datasæt, som du har indlæst. plot(iris$Sepal.Length,iris$Sepal.Width) hist(iris$Sepal.Width) boxplot(iris$Sepal.Length~iris$Species) Du kan også gøre plottene lidt pænere ved at give dem en titel og navne på akserne. Prøv at kigge på dokumentationen for plot() ved at skrive ?plot i R-konsollen. Du kan tilføje ylab, xlab og main (titel) i én af plottene. Prøv også at eksperimentere med farver ved at bruge col. Bemærk dog, at vi vil ændre måden at lave plottene på, når vi begynder at bruge ggplot2. 5) (dataframes) Brug datasættet cars (data(cars)) til at: Lav et scatter plot med speed på x-aksen og dist på y-aksen Tilføj en ny kolon med følgende kode: cars$fast &lt;- cars$speed&gt;15 Brug mean på den nye kolon fast for at finde ud af proportionen af biler, der er hurtige Beregn gennemsnitsværdien af variablen dist for hurtige biler og ikke-hurtige biler hver for sig (brug funktionen tapply). Gem resultatet med &lt;-. Brug barplot til at lave et plot af den gennemsnitlige dist for hurtige og ikke-hurtige biler. 6) (dataframes) En dataframe kan indeholde forskellige datatype (i modsætning til en matrix). Lav en ny dataframe (funktionen data.frame()) med tre kolonner, som hedder “navn”, “alder” og “yndlings_farve” (du kan finde på værdierne selv). Sørg for, at din dataframe har 4 rækker. mydf &lt;- data.frame(&quot;navn&quot;= c(&quot;alice&quot;,&quot;freddy&quot;, ... ), &quot;alder&quot; = c(...), ...) #not run, slette &quot;...&quot; og skrive videre dim(mydf) # fire række og tre kolonner mydf 7) (dataframes) Tilføj en ny kolon random til din oprettede dataframe - hvor værdierne kommer fra en normalfordeling med et gennemsnit på 5 og standardafvigelse på 1 (bruge funktionen rnorm()). mydf$random &lt;- #?? 8) (delmængder af dataframes) Åbn datasættet “ToothGrowth” med følgende kode: data(&quot;ToothGrowth&quot;) ?ToothGrowth Find delmængden af datasættet således at diet (variablen supp) er “OJ” og længden (variablen len) er større end 15. newdf &lt;- ToothGrowth[#skrive her til at lave subset af observationerne,] Hvor mange rækker er der i den nye data frame newdf? Hvor mange unikke værdier er der i variablen dose (brug funktionen unique) ? Find delmængden af datasættet ToothGrowth, hvor variablen dose er 0.5 eller 2.0 (hint: brug %in% eller |) og supp er “VC”. Beregn den gennemsnitlige længde for observationerne i delmængden. 1.12.3 Kort analyse med reaktionstider 9) (indlæse data) Åbn en fil på Absalon ved navn “reactions.txt” ved at bruge funktionen read.table() og gem resultatet i variablen data. Husk at tjekke, om filen indeholder variabelnavne og brug header=T hvis nødvendigt. data &lt;- ... #replace ... 10) (factor variabler) Variablerne subject og time blev indlæst som henholdsvis int (heltal) og chr (character) datatyper, men de skal i stedet være factor variabler. Brug funktionen as.factor() til at konvertere dem til factor variabler. #gør subject til en faktor data$subject &lt;- as.factor(data$subject) ## gør den samme her for time: Hvor mange niveauer er der i hver af de to variabler efter konvertering til faktorvariabler? Prøv funktionerne levels() eller nlevels(). 11) (delmængder af dataframes) Lav to delmængder af det ovenstående datasæt ved at: oprette en delmængde til alle observationer fra tidspunktet “before” ved at vælge rækkerne i dataframen hvor data$time == “before” oprette en delmængde til alle observationer fra tidspunktet “after”. RT_before &lt;- data[#skrive her , ] RT_after &lt;- #skrive her Opret en yderligere delmængde, som viser alle observationer fra tidspunktet “before” med en reaktionstid på mindst 800. Hvor mange personer er der i denne delmængde? RT_before_mindst800 &lt;- #skrive her 12) (mean og tapply) Benyt funktionen mean() til at beregne den gennemsnitlige reaktionstid (variablen RT) for “before” og “after” delmængderne. Brug funktionen tapply() på det oprindelige datasæt data for at beregne den samme middelværdi med mindre kode. tapply(#skrive her,#skrive her,#skrive her) Er reaktionstiderne blevet hurtigere eller langsommere i gennemsnit? 13) (beregn forskellen og mean) Bemærk, at datasættet er ‘paired’ - målingerne er lavet på de samme personer både “before” og “after”. Opret en vector diff, der indeholder forskellene i reaktionstiderne mellem “before” og “after” for hver person. Beregn den gennemsnitlige forskel i rekationstiderne. diff &lt;- #change in reaction time between before and after mean(diff) Tjek, om tegnet på middelværdien stemmer overens med din konklusion fra 11) - hvis den er positiv, betyder det, at reaktionstiderne er blevet langsommere. 14) (lav t-test i R) Lav en t-test (funktionen t.test()) for at teste hypotesen om, at den gennemsnitslige forskel i reaktionstiderne mellem “before” og “after” er forskellig fra 0. t.test(#skrive her..) Find følgende i outputtet fra R: Hvor er test-statistik t? Hvor er p-værdien? Hvad er alternativhypotesen? Husk at skrive en kort sætning med din endelige konklusioner. 1.12.4 Øvelse med CO2 15) (t-test med CO2) Indlæs datasættet med kommandoen data(CO2) Opret en delmængde med kun observationer for planten “Qn1” Beregn den gennemsnitlige optagelse (variablen uptake) for hvert behandlingstype (variablen Treatment) i din delmængde ved hjælp af tapply()-funktionen. Udfør en t-test ved hjælp af t.test()-funktionen for at sammenligne optagelsen mellem de to behandlinger i din delmængde. Skriv en kort sætning med din konklusion. 1.12.5 Ekstra øvelser med statistik tests 16) (Chi-sq) Kør følgende kode til at få en tabel (selve koden er ikke vigtigt): mytable &lt;- structure(c(80L, 97L, 372L, 136L, 87L, 119L), .Dim = 3:2, .Dimnames = structure(list( c(&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;), c(&quot;Died&quot;, &quot;Survived&quot;)), .Names = c(&quot;Class&quot;, &quot;Survival&quot;)), class = &quot;table&quot;) mytable ## Survival ## Class Died Survived ## First 80 136 ## Second 97 87 ## Third 372 119 Tabellen angiver antallet af passagerer ombord skibet ‘Titanic’, som sank den 15. april 1912 efter et sammenstød med et isbjerg 600 km sydøst for Halifax, Nova Scotia i Canada. Tabellen er opdelt i tre klasser (førsteklasse, andenklasse, tredjeklasse) og viser antallet af passagerer, som overlevede tragedien og antallet af passagerer, som døde. Benyt funktionen chisq.test() på tabellen. Hvad er nulhypotesen til testen? Er testen signifikant? Er passagerenes klasse og deres chance for at overleve tragedien uafhængige af hinanden? Hvilken af de tre klasse havde den bedste chance for at overleve? OBS: Vi kommer til at arbejde meget mere med datasættet Titanic i emnet Tidyverse - dag 1! 17) (Korrelation analyse) Åbn datasættet trees og lav et scatter plot med variablen Girth på x-aksen og variablen Volume på y-aksen. data(trees) summary(trees) Anvend funktionen cor.test for at teste, om der er en signifikant korrelation mellem de to variabler. Brug method = \"pearson\" (det er dog faktisk default) cor.test(???, ???,method=&quot;pearson&quot;) Hvad er korrelationen mellem Girth og Volume? Hvad er p-værdien? Er den signifikant? 18) (ANOVA) OBS: hvis du føler dig utryg med funktionen lm() - der kommer en video om det i morgen (i forbindelse med emnet Rmarkdown). Kør følgende kode til at lave variansanalyse, der tester hulhypotesen hvor den gennemsnitlige værdi af variablen Sepal.Width er ens for hver af de tre arter (variablen Species) fra datasættet iris: data(iris) #model under H0: no difference according to group variable Species (1 just means &quot;fit overall mean&quot;) model_h0 &lt;- lm(Sepal.Width ~ 1, data=iris) #model under H1: each level of group variable Species has its own mean model_h1 &lt;- lm(Sepal.Width ~ Species, data=iris) #compare two models - significant p-value equates to choosing H1 model anova(model_h0,model_h1) ## Analysis of Variance Table ## ## Model 1: Sepal.Width ~ 1 ## Model 2: Sepal.Width ~ Species ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 149 28.307 ## 2 147 16.962 2 11.345 49.16 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Kig på outputtet: Hvilken model reflekterer nulhypotesen? Hvilken model reflekterer alternativhypotesen? Hvor er p-værdien? Er der en signifikant forskel i den gennemsnitlige Sepal.Width efter de forskellige Species? Brug funktionen tapply for at finde ud af, hvad er den middelværdi Sepal.Width til hver af de tre arter. 19) (ANOVA) Lav en lignende analyse på datasættet chickwts for at svare på spørgsmålet: Er der en forskel i den gennemsnitlige vægt (variablen weight) efter fodertypen (variablen feed)? Med andre ord er vægt afhængig af fodertypen? data(chickwts) OBS - hvis du er usikker med linær regression gennemgå gerne videoerne til emnet R Markdown og kom tilbage til følgende spørgsmål 20) (Lineær regression) Brug lm til at lave en simpel lineær regression, således at respons variablen Volume er afhængig af variablen Girth (datasæstet trees). mylm &lt;- lm(???, data=trees) Brug summary på din model for at finde følgende værdier: Hvad er r.squared? (multiple) Er variablen Girth signifikant? Hvad er ligningen på den bedste rette linje (husk formen y = ax + b)? 21) (Kort intro til multiple lineær regression) Tag ovenstående model og tilføj variablen Height som en ekstra prediktær (uafhængig) variabel i modellen med en “+” tegn: mylm_height &lt;- lm(??? ~ ??? + ???, data=trees) summary(mylm_height) Bemærk at det ikke betyder, at de to variabler skal lægges sammen, men at vi gerne vil have både variablerne i modellen som uafhængig variabler (med andre ord er Volume afhængig af både Girth og Height). Benyt summary på modellen og prøv at finde følgende: Hvad er den den (multiple) r.squared værdi? Hvor meget ændre den (multiple) r.squared værdi i forhold til modellen med kun variablen Girth? Er Volume signifikant afhængig af Height (efter at man har taget højde for Girth)? Brug funktionen anova til at sammenligne modellen uden Height med modellen med Height anova(#model without height,#model with height) Bemærk, at i dette tilfælde er p-værdien fra ANOVA samme p-værdi fra summary(mylm_height). "],["rmarkdown.html", "Chapter 2 Introduktion til R Markdown 2.1 Hvad er R Markdown? 2.2 Installere R Markdown 2.3 Videodemonstrationer 2.4 Oprette et nyt dokument i R Markdown 2.5 Skrive baseret tekst 2.6 Knitte kode 2.7 Kode chunks 2.8 R beregninger inden for teksten i dokumentet (‘inline code’) 2.9 Working directory 2.10 Matematik 2.11 Problemstillinger 2.12 Færdig for i dag og næste gang 2.13 Ekstra links", " Chapter 2 Introduktion til R Markdown I dag starter vi med at arbejde med R Markdown. Emnet er kort og er designet til at hjælpe dig med at komme i gang med at bruge R Markdown i praksis. Notaterne inkluderer også nogle ekstra muligheder, så du kan indrette dit dokument efter eget ønske. Der er to videoer tilgængelige - den ene er en “quick-start guide” til at komme i gang, og den anden viser en simpel lineær regression i R Markdown. Hvis du ikke har brug for en genopfriskning, kan du stadig udforske mere af funktionaliteten i R Markdown. Efter quizzerne og problemstillingerne er der en worksheet, hvor du kan øve dig yderligere med de typer opgaver, vi vil se i workshopperne. Fra næste gang (fredag) skifter vi emnet til visualiseringer i ggplot2, og vi vil fortsætte med at bruge R Markdown fremadrettet. 2.1 Hvad er R Markdown? R Markdown er en nem og fleksibel måde at arbejde med R i projekter på. Her kan du kombinere din R-kode, output og tekst i samme dokument og generere et pænt HTML-dokument, som potentielt kan deles med andre. Jeg anbefaler, at du bruger R Markdown til alle opgaver i kurset. OBS: Ved eksamen forventer jeg, at du afleverer et HTML-dokument til mig med din “knittede” kode fra din analyse. 2.2 Installere R Markdown R Markdown er, ligesom R, gratis og ‘open source’. Den fungerer indenfor RStudio and kan installeres ved at bruge den følgende kommando: install.packages(&quot;rmarkdown&quot;) 2.3 Videodemonstrationer Jeg har lavet to videoer, som du kan se nedenfor: Video 1: I denne video viser jeg, hvordan du: opretter et nyt dokument i R Markdown skriver tekst i dokumentet bruger “knit” til at lave et HTML-dokument opretter og kører kodechunks. Link her hvis det ikke virker nedenunder: https://vimeo.com/702416505 ## ## Vedhæfter pakke: &#39;vembedr&#39; ## Det følgende objekt er maskeret fra &#39;package:lubridate&#39;: ## ## hms Video 2: I denne video viser jeg en kort lineær regression analyse: Hvordan man indlæser et datasæt og laver et plot af datasættet En lynhurtig gennemgang af ligningen for en ret linje Hvordan man anvender funktionen lm() til at fitte en lineær model Fortolkning af resultaterne af modellen og deres statistiske betydning. Link her hvis det ikke virker nedenunder: https://vimeo.com/701240044 2.4 Oprette et nyt dokument i R Markdown Man åbner et nyt R Markdown dokument i RStudio ved at klikke på “File” &gt; “New File” &gt; “R Markdown…”. Alternativt kan man klikke på “+” knappen i øverste venstre hjørne af RStudio vinduet og vælge “R Markdown”. Hvordan man åbner et nyt R Markdown dokument Dernæst angiver man en titel (som kan ændres senere hvis nødvendigt) og specificerer, at outputtet skal være i HTML-format. I dette kursus arbejder vi kun med HTML-dokumenter, men der er også andre muligheder, som du er velkommen til at prøve (PDF/Word/Shiny osv.). Hvordan man åbne et nyt R Markdown dokument 2.4.1 YAML Den første sektion af dokument skrives i hvad der kaldes for ‘YAML’. (Dette står for ‘YAML Ain’t Markup Language’). YAML-sektionen bruges til at definere en række indstillinger og metadata for dokumentet, såsom titel, forfatter, dato og outputformat. Denne sektion indrammes typisk af tre bindestreger (—) øverst og nederst: YAML eksempel I dette eksempel angiver vi titlen på rapporten som “test”, forfatterens navn, datoen og outputformatet (HTML-dokument). Du kan tilføje yderligere indstillinger og tilpasse outputformatet ved at ændre eller udvide YAML-headeren. I de fleste tilfælde nøjes vi dog med at bruge standard indstillinger. Hvis man gerne vil lære mere om de forskellige muligheder med YAML, kan man læse her: https://bookdown.org/yihui/rmarkdown/html-document.html Man kan også se en liste af muligheder her på dette cheatsheet: https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf 2.4.2 Globale options Der er også tekst som ser ud som følgende: Globale muligheder Ved at bruge funktionen opts_chunk$set() kan du angive globale indstillinger, der styrer udseendet af det endelige dokument. I dette tilfælde er de fleste parametre sat til deres ‘default’ eller standardværdier (da de ikke nævnes eksplicit), og echo er den eneste parameter, der har en værdi angivet. Når echo er sat til TRUE, betyder det, at når du “knitter” din kode (processen der omdanner R Markdown-filen til et HTML-dokument, som beskrevet nedenfor), vil både den udførte kode og dens output blive vist i det genererede HTML-dokument. Funktionen opts_chunk$set() giver dig mulighed for at kontrollere adskillige aspekter af dit dokument på en global måde, såsom visning af advarsler og beskeder, cacheindstillinger og grafikindstillinger. For eksempel, advarsler og beskeder undertrykkes ved at sætte warning = FALSE og message = FALSE (du kan selv afprøve dette). Bemærk, at disse globale indstillinger kan overstyres for individuelle kodeblokke, hvis det er nødvendigt. 2.5 Skrive baseret tekst Her er nogle brugbare muligheder for at skrive tekst i opgaverne eller rapporter: *italic* **bold** _italic_ __bold__ italic bold italic bold 2.5.1 Headers Man kan også lave sektioner: # Header 1 ## Header 2 ### Header 3 Caption for the picture. 2.5.2 liste * Item 1 * Item 2 + Item 2a + Item 2b Item 1 Item 2 Item 2a Item 2b 2.6 Knitte kode Du bruger Knit til at omdanne R Markdown-filen til HTML-format. Når du trykker på Knit-knappen, bliver alle kodeblokke i filen udført, og et HTML-dokument genereres og vises. Bemærk, at koden udføres på ny hver gang du knitter, uafhængigt af indholdet i dit aktuelle RStudio-workspace. Det betyder, at hvis du for eksempel har indlæst pakken tidyverse i dit RStudio-arbejdsområde, men har glemt at inkludere library(tidyverse) eksplicit i begyndelsen af dit R Markdown-dokument, vil du modtage en fejlmeddelelse, hvis du bruger funktioner fra tidyverse andre steder i dokumentet. 2.7 Kode chunks Du skriver R-kode inden for såkaldte “chunks” i R Markdown-dokumenter. Du kan oprette en ny kodeblok på flere måder - enten ved at klikke på knappen Insert a new code chunk øverst i RStudio, eller ved at trykke på Cmd+Option+I på tastaturet (hvis du bruger en Mac) eller Ctrl+Alt+I (hvis du bruger Windows). Det er værd at huske denne shortcut/genvej, da det kan spare dig meget tid i det lange løb! Her er et eksempel af en kodechunk: # This is a chunk, let&#39;s write som R code x &lt;- 1 x + 1 ## [1] 2 For at køre en chunk skal du trykke på den grønne pil øverst i højre hjørne af selve chunk’en (der hedder Run Current Chunk når du holder musen over den). Resultatet kan ses lige nedenunder, som vist ovenfor. Bemærk, at når du arbejder med dit R Markdown dokument, er det generelt hurtigere at bruge den grønne pil / Run Current Chunk i stedet for at knitte hele dokumentet hver gang man vil køre kode. Det skyldes, at du her kun kører den enkelte chunk i stedet for hele dokumentet på ny (herunder indlæsning af pakker og eventuelle store filer), som er tilfældet med Knit. 2.7.1 Et godt råd når man arbejder med chunks For længere opgaver er det god praksis løbende at sikre, at du kan generere et HTML-dokument ved at knitte, selvom du kører din chunks lokalt, mens du udvikler din kode. Med andre ord skal du sørge for, at du ikke få alvorlige fejlmeddelelser, der forhindrer din kode i at blive knittet. Det er dit ansvar at sikre, at din kode fungerer som helhed, og at du dermed kan producere et HTML-dokument med din løsninger. 2.7.2 Chunk indstillinger I R Markdown er der mange muligheder for at styre hver enkelt chunk i dit dokument - hvordan skal R håndtere koden med hensyn til evaluering og præsentation (især med hensyn til tabeller og plots) af en bestemt chunk i dit dokument? Det afhænger meget af, hvem du gerne vil viser dit dokument til. For eksempel, i de nuværende kursusnotater vil jeg gerne have generelt, at du ser al min kode (en global indstilling), men nogle gange vil jeg foretrække noget andet - en chunk, der viser noget, jeg ikke vil have kørt, eller ændre på størrelsen på et plotte i en bestemt chunk. For eksempel ser en chunk med indstillingen eval=FALSE sådan ud (fjern # symbolet) #```{r,eval=FALSE} # #``` Her er nogle muligheder (sektionen “Embed code with knitr syntax”): https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf Her er seks populære muligheder: include = FALSE forhindrer både kode og resultater i at blive vist i den færdige fil. R Markdown kører stadig koden i kodeblokken, og resultaterne kan bruges af andre kodeblokke. echo = FALSE forhindrer koden, men ikke resultaterne, i at blive vist i den færdige fil. Dette er en nyttig måde at integrere figurer på. message = FALSE forhindrer beskeder, der genereres af koden, i at blive vist i den færdige fil. warning = FALSE forhindrer advarsler, der genereres af koden, i at blive vist i den færdige fil. fig.cap = \"...\" tilføjer en billedtekst til grafiske resultater. eval = FALSE evaluerer ikke koden 2.8 R beregninger inden for teksten i dokumentet (‘inline code’) I nogle tilfælde ønsker man køre R kode “inline”, det vil sige, direkte inden for teksten, for eksempel inden for en sætning. Dette gøres ved at skrive på følgende måde: Her er min `kode` Ovenstående ser sådan ud, når det er skrevet direkte inden for teksten: Her er min kode I dette tilfælde, er der ikke noget R kode, der er blevet kørt. Hvis man vil køre R kode inden for teksten, skriver man (for eksempel): Det gennemsnitlige antal af observationer er `r mean(c(5,7,4,6,3,3))` Ovenstående ser sådan ud, når det er skrevet direkte inden for teksten: Det gennemsnitlige antal observationer er 4.6666667 Bemærk, at hvis man glemmer ‘r’, bliver koden ikke kørt: Det gennemsnitlige antal af observationer er `mean(c(5,7,4,6,3,3))` giver: Det gennemsnitlige antal af observationer er mean(c(5,7,4,6,3,3)) At bruge kode inline kan være en stor fordel, når man gerne vil skrive noget om an analyse, hvor man referere til forskellige statistike beregninger, som man har udført i R (eksempelvis en middelværdi eller p-værdi). Hvis man skriver eller kopierer et tal direkte, og datasættet eller analysemetoden ændre sig af en eller anden grund, bliver beregningerne inden for teksten ikke opdateret, og så risikerer man at have en fejl i den endelige rapport. Ved at bruge inline code, så opdateres beregningerne automatisk, uden at man behøver at tænke over det. 2.9 Working directory Bemærk at måden man sætter en working directory er ændleredes i R Markdown i forhold til base-R. Hvis man bruger setwd() i en chunk, sætter man kun den working directory i den pågældende chunk og ikke i de efterfølgende chunks. I R Markdown er standarden (default), at din working directory er mappen, hvor du gemmer din .Rmd fil. Hvis du genre vil bruge andet, kan du tilføje knitr::opts_knit$set(root.dir = '/tmp') til din globale indstillinger chunk øverst i din fil, hvor '/tmp' skal ændres til din ønskede mappe. ```{r, setup, include=FALSE} knitr::opts_knit$set(root.dir = &#39;/tmp&#39;) ``` 2.10 Matematik Man kan også skrive matematik (LaTeX) i R Markdown - for eksempel vil $\\int_0^5 x^2 dx$ se ud som \\(\\int_0^5 x^2 dx\\) i dit HTML-dokument. Jeg forventer ikke, at du lærer LaTeX, men det er af og til brugbart - for eksempel en retlinjet ligning er $y = 3.4x + 2.1$ giver \\(y = 3.4x + 2.1\\) eller en hypotese: $H0: \\mu = 0$ giver \\(H0: \\mu = 0\\). Det er op til dig, hvor meget du bruger matematik i dine egne dokumenter. 2.11 Problemstillinger Der er en kort quiz i Absalon, som hedder “Quiz - R Markdown”. Opret et nyt R Markdown-dokument i RStudio. Prøv at lave en liste og nogle overskrifter i forskellige størrelser. Klik nu på Knit-knappen og kontroller, at et HTML-dokument vises på din skærm. Rediger titlen (som er en del af din YAML-header øverst i din fil) - kald dit dokument “My first R Markdown document” og klik på Knit igen for at se ændringen i dit HTML-dokument. Opret en ny R-kodeblok og tilføj noget kode, for eksempel: x &lt;- rnorm(20,1,2) #make a sample of normally distributed data plot(x) Husk genvejen CMD+OPT+I eller CTRL+WIN+I når man oprette en chunk (det sparer tid) Klik på den grønne pil Prøv også at køre en linje ad gangen med CMD+Enter/CTRL+Enter Lav flere chunks med forskellig kode efter eget valg Klik på “knit” og bemærk, at det tager længere tid at “knit” hver gang du ændrer noget, end når du bare kører chunks individuelt indenfor dit dokument Klik på “hjul”-knappen i øverste højre hjørne af en af dine chunks og prøv at ændre de forskellige chunk-indstillinger. Klik på “knit” for at se, hvad der sker. Hver gang du knitter, laver du et HTML-dokument. Prøv nu at lave en anden type dokument i stedet for - erstat html_document med word_document i YAML (toppen af din .Rmd fil) Se her for endnu flere muligheder: https://bookdown.org/yihui/rmarkdown/output-formats.html Tilføj følgende chunk til dit dokument og klik på “knit”. Få du en fejlmeddelelse? data(mtcars) mtcars %&gt;% filter(cyl==6) Bemærk, at du får en fejlmeddelelse, fordi du endnu ikke har indlæst den nødvendige pakke for at få koden til at virke. Det kan ske, selvom du måske har indlæst pakken i “Console” eller i fanebladet “Packages”. Prøv først at køre “library(tidyverse)” i Console og derfeter prøve at knitte dit dokument igen - du får stadig en fejlmeddelelse. Tilføj library(tidyverse) øverst i din chunk. Nu skulle dit dokument kunne knitte. Erstat linjen output: html_document med følgende i din YAML metadata øverst i din .Rmd fil: output: html_document: code_folding: hide Knit og se hvad, der sker. Erstat hide med show og se forskellen. Brug $ $ til at skrive en ligning ind i teksten i din .Rmd fil. Prøv for eksempel $\\bar{x}_{i} = \\frac{1}{n}\\sum_{i=1}^{n} x_{i}$ og knitte dit dokument for at tjekke, om du får formlen til middelværdien. (Worksheet) På Absalon har jeg lagt en R Markdown (.Rmd) fil kaldet “R Markdown opgave”, som du kan bruge til at starte med at arbejde med R Markdown-baserede opgaver. Det kombinerer koncepter fra det forudgående kapitel om grundlæggende ting i R og statistik. 2.12 Færdig for i dag og næste gang Husk at sende mig eventuelle spørgsmål, som jeg kan svare på enten direkte eller i forelæsning næste gang. Næste gang begynder vi at arbejde vi med R-pakken ggplot2, der bruges til at lave høj kvalitet visualiseringer fra datasæt. 2.13 Ekstra links Her er en ‘quick tour’ https://rmarkdown.rstudio.com/authoring_quick_tour.html Handy R Markdown Cheatsheet: RStudio has published numerous cheatsheets for working with R, including a detailed cheatsheet on using R Markdown! The R Markdown cheatsheet can be accessed from within RStudio by selecting Help &gt; Cheatsheets &gt; R Markdown Cheat Sheet. "],["visual1.html", "Chapter 3 Visualisering - ggplot2 dag 1 3.1 Inledning og videoer 3.2 Transition fra base R til ggplot2 3.3 Vores første ggplot 3.4 Lidt om ggplot2 3.5 Specificere etiketter og titel 3.6 Ændre farver 3.7 Ændre tema 3.8 Forskellige geoms 3.9 Troubleshooting 3.10 Problemstillinger 3.11 Næste gang", " Chapter 3 Visualisering - ggplot2 dag 1 3.1 Inledning og videoer Dette kapitel giver en introduktion til, hvordan man visualiserer data med R-pakken ggplot2. 3.1.1 Læringsmålene for dag 1 I skal være i stand til at: Forstå hvad “Grammar of Graphics” betyder og sammenhængen med den ggplot2-pakke Lære at bruge funktionen ggplot og den relevante geoms (geom_point(), geom_bar(), geom_histogram(), geom_boxplot(), geom_density()) Lave en ‘færdig’ figur med en titel og korrekte etiketter på akserne Begynde at arbejde med farver og temaer 3.1.2 Hvad er ggplot2? De fleste i kurset har brugt funktionen plot(), som er den standard base-R funktion til at lave et plot. Man kan fortsætte med at bruge plotfunktioner fra base-pakken, men det kan være meget tidskrævende, især når man vil lave mere komplekse og pænere plots. En alternativ løsning er pakken ggplot2, som står for “Grammar of Graphics” (se nærmere forklaring nedenfor). ggplot2 er den mest populær pakke fra tidyverse. Som vi vil se i dette kapitel, har den en ret logisk tilgang, hvor man opbygger et plot i forskellige komponenter. Det kan virke uoverskueligt i starten, men når man først har lært det, er det faktisk meget intuitivt. Det nyttige i at lære ggplot2 kan også ses når man begynder at integrere de andre tidyverse-pakker fra kapitel 4. 3.1.3 Brugen af materialerne Jeg har optaget videoer, hvor jeg viser nogle ‘quick-start’ type eksempler i min RStudio. Videoerne er ikke designet til at indeholde alle detaljer, men til at fungere som udgangspunkt for at komme i gang med øvelserne. Vær opmærksom på, at al kode, der vises i videoerne, også kan findes i kursusnotaterne, hvis du selv vil afprøve den. Jeg anbefaler, at du bruger kursusnotaterne som en reference gennem kurset, når man arbejder på opgaverne. Vær også opmærksom på, at jeg nogle gange introducerer nye ting i selve øvelserne. 3.1.4 Video ressourcer I video 1 demonstrerer jeg, hvordan man lave sit første plot med ggplot2. Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/701245598 I video 2 dækker vi boxplots. Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/701245695 I video 3 demonstrerer jeg barplots. Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/704025240 Video 4: Histogram og density plots Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/703699213 3.2 Transition fra base R til ggplot2 Vi starter som udgangspunkt med base-R og viser, hvordan man laver et lignende plot med ggplot2. Til dette formål bruger vi det indbyggede datasæt, der hedder iris. Datasættet er meget berømt, og det er næsten sikkert, at du allerede er stødt på det uden for dette kurus, enten på nettet eller i forbindelse med andre kurser, som handler om R. Datasættet var oprindeligt samlet af statistikeren og biologen Ronald Fisher i 1936 og indeholder 50 stikprøver, der dækker forskellige målinger for hver af tre arter af planten iris (Iris setosa, Iris virginica og Iris Versicolor). Som vi også så i grundlæggende R, kan man indlæse et indbyggede datasæt med hjælp af funktionen data(). data(iris) Først vil vi have et overblik over datasættet. Til at gøre dette bruger vi summary(): summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## Forestil, at vi gerne vil lave et plot, som viser sammenhængen mellem længden og bredden af sepal (bægerblad), eller specifikt er vi interesseret i kolonnerne iris$Sepal.Length og iris$Sepal.Width. Lad os starte med at visualisere variablerne i base-R, ved at bruge plot: plot(iris$Sepal.Length, iris$Sepal.Width) Man kan gøre det meget pænere eksempelvis ved at bruge forskellige farver til at betegne de forskellige arter, eller ved at give en hensigtsmæssig overskrift eller aksenavne. 3.3 Vores første ggplot Vi vil imidlertid fokusere på at lave et lignende plot med pakken ggplot2. Hvis man ikke allerede har gjort det, så husk at indlæse pakken i R for at få nedenstående koder til at virke. #install.packages(&quot;ggplot2&quot;) #hvis ikke allerede installeret library(ggplot2) For at lave et plot med ggplot2 tager man altid udgangspunkt i funktionen ggplot(). Først specificerer vi vores data - altså at vi gerne vil bruge dataframe iris. Dernæst angiver vi indenfor funktionen aes() (som sidder indenfor ggplot()), at x-aksen skal være Sepal.Length og y-aksen Sepal.Width. Det ser sådan ud: ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) Koden fungerer, men bemærk, at plottet er helt tomt og derfor ikke særligt brugbart. Men der er skabt et grundlag (se aksenavne osv.). Det er tomt fordi vi endnu ikke har specificeret, hvilken plottype det skal være - for eksempel søljediagram/barplot, histogram, punktplot/scatter plot (jeg vælge de engelske begreber herfra for at skabe den bedste sammenhæng med koden). Vi vil gerne bruge et scatter plot, som i ggplot2 er angivet med funktionen geom_point(). Vi tilslutter derfor funktionen geom_point() til den ggplot() funktion, som vi allerede har specificeret. Husk altid, at man bruger + til at forbinde de to “komponenter” (altså ggplot() og geom_point()) af plottet (ellers få vi fortsat et tomt plot). Koden er således: ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + geom_point() Bemærk, at vi ikke har skrevet noget indeni de runde parenteser i funktionen geom_point(). Det betyder, at vi accepterer alle standard- eller ‘default’ parametre, som funktionen tager. Hvis vi vil have noget andet end de standard parametre, kan vi godt specificere det. For eksempel kan vi gøre punkterne lidt større end ved standarden (prøve at tjekke ?geom_point() for at se en list overfor de mulige parametre, som man kan justere): ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + geom_point(size=3) Vi har nu et plot, som vi kan sammenligne med det ovenstående plot, vi lavet i base-pakken. Ligesom i base-pakken vil vi gerne tilføje nogle ting for at gøre vores plot til vores færdige figur.. Her i ggplot2 gøres det ved at tilføje flere komponenter ovenpå, med brugen af +, ligesom vi gjorde da vi tilføjede geom_point() til ggplot(). Første vil jeg gerne skrive nogle orde om ggplot2 generelt, og filosofien bag. 3.4 Lidt om ggplot2 3.4.1 Syntax Som vi har lige set, ggplot() tager altid udgangspunkt i en dataframe, som vi specificerer først. I ggplot() indeholder den dataframe variablerne vi skal bruge til at få lavet figuren. Til at gøre det til noget mere konkret, lad os sammenligne koden mellem base-pakken og ggplot() til vores iris data. I base-R angav vi direkte vektorer iris$Sepal.Length og iris$Sepal.Width som parametre x og y, der tager henholdsvis først og anden-plads i funktionen plot(). Til gengæld i ggplot(), specificerer man først den hele dataramme i den første plads, og så bagefter med brugen af aes() angav vi hvordan x-aksen og y-aksen ser ud. #baseplot solution plot(iris$Sepal.Length, iris$Sepal.Width) #ggplot2 solution ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + geom_point() En anden fordel af ggplot2() er, at man kan fortsætte med at forbedre plottet ved at tilføje ting ovenpå det eksisterende plot, i hvilket kan beskrives som en lagbaseret tilgang. Dette gøres intuitivt ved at bruge “+”. Man kan derfor starte med noget simpelt, og gradvist opbygge det noget mere kompleks. Dette er uafhængigt af den type plot, vi laver. 3.4.2 Hvad betyder egentlig grammar of graphics? Den gg i ggplot2 står for grammar of graphics, og filosofien er, at man skal definere en sætningsstruktur til de figurer, man laver. Med andre ord består vores figur af forskellige komponenter, som man forbinder med “+”.. Her er en beskrivelse af de forskellige komponenter, som bruges til at opbygge et plot: Data: Datarammer tages altid som udgangspunkt. Aesthetics: Variabler til x-aksen eller y-aksen, farve, form eller størrelse Scale: Skalering af værdier eller repræsentation af flere værdier Geometries: Også kaldet geoms - bestemmer hvilken type plot, der skal laves, som f.eks. søjler, punkter, linjer osv. Statistics: Tilføjer f.eks. mean, median eller kvartiler, som beskriver dataene. Facets: Opretter subplots baseret på flere dimensioner. Coordinate system: Transformerer akser og ændrer afstanden for de viste data. 3.4.3 Globale versus lokale æstetik I de fleste tilfælde bruger man funktionen aes() indenfor ggplot(), hvilket betyder, at variablerne, der er specificeret inden for aes(), gælder globalt over alle komponenter i plottet. Man kan faktisk også skrive en lokal aes() inden for selve geom-funktionen, som i følgende eksempel: ggplot(iris) + geom_point(aes(x=Sepal.Length, y=Sepal.Width)) Vi får det samme plot som før, men det er kun geom_point(), der er påvirket af specificeringen inden for aes(). I simple situationer som dette er der ingen forskel, men når man har mange forskellige komponenter i spil, kan det nogle gange give mening at bruge lokale æstetik. 3.5 Specificere etiketter og titel Vi tager udgangspunkt i plottet, som vi har lavet i ovenstående, og prøver at gøre det bedre ved at tilføje nye etiketter og en titel. I ggplot kan man opdatere y-akse og x-akse etiketter ved at bruge henholdsvis ylab og xlab: ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + geom_point(size=3) + xlab(&quot;Sepal Length&quot;) + ylab(&quot;Sepal Width&quot;) Vi tilføjer en titel med funktionen ggtitle(): ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) + geom_point(size=3) + xlab(&quot;Sepal Length&quot;) + ylab(&quot;Sepal Width&quot;) + ggtitle(&quot;Scatter plot of Sepal Width vs Sepal Length&quot;) 3.6 Ændre farver I ggplot2 kan man bruge “automatisk” farver for at skelne mellem de tre forskellige Species i datasættet iris. I den næste lektion vil vi dække, hvordan man kan være mere fleksibel ved at sætte farver manuelt, men ofte vil vi bare bruge den nemme løsning som udgangspunkt og eventuelt rette op på det senere med en ny komponent, hvis der er behov for det. Vi skriver color=Species indenfor aes(), som i følgende eksempel. Bemærk, at der kommer en ‘legend’ med, der fortæller os, hvilken art, der får hvilken farve. ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,color=Species)) + geom_point(size=3) + xlab(&quot;Sepal Length&quot;) + ylab(&quot;Sepal Width&quot;) + ggtitle(&quot;Scatter plot of Sepal Width vs Sepal Length&quot;) 3.7 Ændre tema Det standard tema har en grå baggrund og “grid” linjer, men man kan godt vælge noget andet. For eksempel kan man tilføje theme_minimal() som i nedenstående eksempel. Her får vi en hvid baggrund i stedet, mens man stadig får grid linjer. Man kan afprøve forskellige temaer (for eksempel theme_classic(), theme_bw()), og se, hvilket tema, der fungerer bedst i det enkelte plot. ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,color=Species)) + geom_point(size=3) + xlab(&quot;Sepal Length&quot;) + ylab(&quot;Sepal Width&quot;) + ggtitle(&quot;Scatter plot of Sepal Width vs Sepal Length&quot;) + theme_minimal() Her er nogle eksempler på mulige temaer, som du kan bruge i dine plotter (det er dog generelt op til dig). tema theme_grey() theme_classic() theme_bw() theme_dark() theme_minimal() theme_light() Se også her, hvis du er interesseret i flere temaer: https://r-charts.com/ggplot2/themes/ 3.8 Forskellige geoms Indtil videre har vi kun arbejdet med geom_point() for at lave et scatter plot, men der er også andre “geoms”, som kan bruges til forskellige typer af plots. Her er en liste over nogle af de mest almindelige geoms: geom plot geom_point() scatter plot geom_bar() barplot geom_boxplot() boxplot geom_histogram() histogram geom_density() density For at lave disse geoms, skal man tilføje dem til ggplot()-kommandoen ved at bruge +, på samme måde som vi gjorde med geom_point(). Der kan dog være specifikke overvejelser, der er værd at have i tankerne for nogle plot-typer, før man bruger dem. 3.8.1 Boxplot (geom_box) For at lave et boxplot af Sepal.Length opdelt efter Species, angiver vi Species på x-aksen og Sepal.Length på y-aksen. Vi vil også have, at hver art få sin egen farve, så bruger vi fill=Species. ggplot(data=iris, aes(x=Species, y=Sepal.Length,fill=Species)) + geom_boxplot() + ylab(&quot;Sepal Length&quot;) + ggtitle(&quot;Boxplot&quot;) + theme_minimal() Lave punkter ovenpå Det kan ofte være nyttigt at plotte de faktiske datapunkter oven på et boxplot, så man kan se både fordelingen i dataene samt de rå data. En løsning er at benytte geom_point() ved at tilføje det som komponent over vores eksisterende kode. ggplot(data=iris, aes(x=Species, y=Sepal.Length,fill=Species)) + geom_boxplot() + geom_point() + ylab(&quot;Sepal Length&quot;) + ggtitle(&quot;Boxplot with points overlayed&quot;) + theme_minimal() Man kan dog se, at det ikke er særlig informativt, da alle punkter er på den samme lodrette linje. Hvis der er mange punkter med samme eller næsten samme værdier, kan man ikke se de fleste af dem i plottet. En bedre løsning er at indføre noget tilfældighed i punkterne langs x-aksen, så at man tydeligere kan se dem. Dette kaldes “jitter”, og man specificere jitter ved at bruge geom_jitter() i stedet for geom_point(). ggplot(data=iris, aes(x=Species, y=Sepal.Length,fill=Species)) + geom_boxplot() + geom_jitter() + ylab(&quot;Sepal Length&quot;) + ggtitle(&quot;Boxplot with jitter&quot;) + theme_minimal() Man kan også specificere alpha, som gøre punkterne mere gennemsigtige og mindre markante. Man kan også ændre på width, som kontrollerer deres spredning langs x-axsen. ggplot(data=iris, aes(x=Species, y=Sepal.Length,fill=Species)) + geom_boxplot() + geom_jitter(alpha=0.5,width=0.2) + ylab(&quot;Sepal Length&quot;) + ggtitle(&quot;Boxplot with jitter and transparency&quot;) + theme_minimal() Fjerne legend hvis unødvendige Man kan se, at når man specificerer farver, får man en legende på højre side af plottet. I dette tilfælde er det faktisk ikke nødvendigt, da man kan se uden legende, hvad de tre boxplots refererer til. Derfor fjerner vi legenden fra plottet ved at bruge theme(legend.position=\"none\"). ggplot(data=iris, aes(x=Species, y=Sepal.Length,fill=Species)) + geom_boxplot() + geom_jitter() + ylab(&quot;Sepal Length&quot;) + ggtitle(&quot;Boxplot with jitter and no legend&quot;) + theme(legend.position=&quot;none&quot;) 3.8.2 Barplot (geom_bar) Med ggplot() kan man repræsentere data i et barplot ved at bruge geom_bar(). Her vil vi gerne tælle antallet af observationer for hver art (variablen Species) og visualisere dem som søjler. Indenfor geom_bar() specificerer vi derfor stat=\"count\". Vi bruger også fill=Species for at lave en forskellig farve automatisk for hver af de tre arter. Bemærk, at det var color=Species i det forudgående plot, når vi anvendte geom_point(). Det skyldes, at color bruges til punkter og linjer, mens fill er til større områder, der bliver udfyldt, såsom søjler og histogrammer. ggplot(iris, aes(x=Species,fill=Species)) + geom_bar(stat = &quot;count&quot;) + ggtitle(&quot;Number of observations by species&quot;) + theme_minimal() Barplot: stack vs dodge Hvis man har flere katagoriske variabler, kan man lave barplots på forskellige måder. Da der er en ekstra katagorisk variabel i datasættet, laver jeg én, der hedder Sepal.Group, der skelne imellem Long og Short værdier af variablen Sepal.Length. Her specificerer jeg bare (med funktionen ifelse()), at hvis Sepal.Length er længere end den gennemsnitlige Sepal.Length, så er det betragtet Long, ellers er det Short, som i følgende: iris$Sepal.Group &lt;- ifelse(iris$Sepal.Length&gt;mean(iris$Sepal.Length), #test &quot;Long&quot;, #if TRUE &quot;Short&quot;) #if FALSE Når jeg laver en barplot med de to variabler, tilføjer jeg Sepal.Group med fill, og ggplot splitter antal observationer efter Sepal.Group med farver som repræsenterer Sepal.Group, og tilføjer en tilsvarende legende. ggplot(iris, aes(x=Species, fill=Sepal.Group)) + geom_bar(stat = &quot;count&quot;) + ggtitle(&quot;Number of observations by species&quot;) + theme_minimal() Mange gange foretrækker man at få søjlerne stående ved siden af hinanden i stedet for at overlappe. Dette kan opnås ved blot at tilføje position=\"dodge\" ind i geom_bar(). ggplot(iris, aes(x=Species, fill=Sepal.Group)) + geom_bar(stat = &quot;count&quot;, position = &quot;dodge&quot;) + ggtitle(&quot;Number of observations by species&quot;) + theme_minimal() Som et eksempel på fleksibiliteten i pakken ggplot2, kan jeg nævne, at det kan være irriterende, når bredden af søjlen for arten setosa i et barplot er dobbelt så bred som de andre søjler, fordi der ikke er nogen observationer i setosa-gruppen med en “Long” værdi i variablen Sepal.Group. En løsning på dette kan findes ved at tilføje position=position_dodge2(preserve = \"single\") i geom_bar(). Denne parameter gør bredden på alle søjler ens, uanset om der er data i alle kategorier eller ej. ggplot(iris, aes(x=Species, fill=Sepal.Group)) + geom_bar(stat = &quot;count&quot;, position = position_dodge2(preserve = &quot;single&quot;)) + ggtitle(&quot;Number of observations by species&quot;) + theme_minimal() 3.8.3 Histogram (geom_histogram) Et histogram bruges til at give et overblik over, hvordan dataene fordeler sig. Med ggplot2 kan man lave et histogram med geom_histogram(). Den x-akse variabel skal være en kontinuerlig variabel. Her specificerer vi, at vi gerne vil have et histogram for hver art (Species). ggplot(data=iris, aes(x=Sepal.Length, fill=Species)) + geom_histogram() + xlab(&quot;Sepal Length&quot;) + ggtitle(&quot;Iris histogram&quot;) + theme_minimal() Man kan også gøre det nemmere at skelne mellem de tre arter ved at sætte alpha=0.5 inden for geom_histogram og ved at angive en linje farve som mulighed ind i geom_histogram(). ggplot(data=iris, aes(x=Sepal.Length, fill=Species)) + geom_histogram(alpha=0.5,color=&quot;black&quot;) + xlab(&quot;Sepal Length&quot;) + ggtitle(&quot;Iris histogram&quot;) + theme_minimal() 3.8.4 Density (geom_density) Med et density plot kan man, ligesom med et histogram, se fordelingen af dataene i form af en glat eller “smooth” kurve. ggplot(data=iris, aes(x=Sepal.Length, color=Species)) + geom_density() + xlab(&quot;Sepal Length&quot;) + ggtitle(&quot;Density plot&quot;) + theme_minimal() Density plot med fill og gennemsigtig farver Vi kan angive en værdi for alpha indenfor geom_density(). Den parameter alpha specificerer gennemsigtigheden af de density kurver i plottet. ggplot(data=iris, aes(x=Sepal.Length, fill=Species)) + geom_density(alpha=0.5) + xlab(&quot;Sepal Length&quot;) + ggtitle(&quot;Density plot with alpha=0.5&quot;) + theme_minimal() Tilføje middelværdi linjer Vi bruger funktionen tapply() til at beregne middelværdierne af Sepal.Length for hver af de tre Species. Vi kan derefter tilføje dem som lodrette linjer til vores plot. Her bruger vi geom_vline() (OBS det er geom_hline(), hvis man vil have en vandret linje) og fortæller, at xintercept skal være lig med de middelværdier, som vi har beregnet. Parameteren lty=2 betyder, at vi gerne vil have en stiplede (“dashed”) linje. means &lt;- tapply(iris$Sepal.Length,iris$Species,median) ggplot(data=iris, aes(x=Sepal.Length, color=Species)) + geom_density(alpha=0.5) + xlab(&quot;Sepal Length&quot;) + ggtitle(&quot;Density plot with alpha=0.5&quot;) + geom_vline(xintercept = means,lty=2) + theme_minimal() 3.8.5 Line plot (geom_line()) geom_line() kan bruges til at lave linjediagrammer. Her indlæser jeg datasættet population og laver en delmængde til landene i Skandinavien. library(tidyr) data(population) population_scand &lt;- population[population$country %in% c(&quot;Denmark&quot;,&quot;Sweden&quot;,&quot;Norway&quot;,&quot;Finland&quot;),] head(population_scand) ## # A tibble: 6 × 3 ## country year population ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Denmark 1995 5232582 ## 2 Denmark 1996 5254383 ## 3 Denmark 1997 5276683 ## 4 Denmark 1998 5298680 ## 5 Denmark 1999 5319410 ## 6 Denmark 2000 5338283 Når tallene i variablen population er ret store, kan det være en god idé at normalisere, så de betegner befolkningsstørrelser i millioner. population_scand$population &lt;- population_scand$population/1e06 Her laver jeg et plot med geom_line(), så vi kan se udviklingen i befolkningsstørrelserne over tid. For at få det til at virke, skal man huske at angive group inden for aes(), udover at man specificerer farven med colour: ggplot(data = population_scand, aes(x = year, y = population, group = country, colour = country)) + geom_line() + labs(title = &quot;Populations in Scandinavia over time&quot;, x = &quot;År&quot;, y = &quot;Befolkningsstørrelse i millioner&quot;) + theme_minimal() 3.9 Troubleshooting Her er blot en lille liste over nogle ting, der kan forårsage fejl, når man kører kode med ggplot2. Jeg tilføjer også andre ting, som kan opstå i vores lektion :). ggplot(data=iris, aes(....)): Husk her, at data=iris er korrekt og ikke Data=iris (R skelner mellem store og små bogstaver). Man kan også undlade at bruge data= og skrive bare iris i stedet for. Forkert stavning: Dobbelttjek, at du har stavet variabel- eller funktionsnavne korrekt. Glemt +-symbol: For at forbinde komponenterne i plottet skal man huske at tilføje + i slutningen af en linje og skrive de næste komponenter bagefter (man behøver ikke at skrive hver komponent på en ny linje, men det gør det nemmere at læse koden). Skrev %&gt;%-symbolet i stedet for +: De øvrige pakker fra tidyverse bruger %&gt;%. Glemt parentes: Her har man glemt den sidste parentes, der skal være fill=Species)) og ikke fill=Species). Man får bare en +, fordi R forventer, at man fortsætter med at skrive mere kode. &gt; ggplot(data=iris, aes(x=Sepal.Length, fill=Species) + fill og colour - indenfor aes() refererer fill til at man fylder fk. bars eller regioner med farver, og colour referere til farven af linjer eller punkter. 3.10 Problemstillinger 1) Quiz på Absalon - den hedder Quiz - ggplot2 part 1. OBS: Husk at lave følgende øvelser i R Markdown. Det er god praksis at sikre, at jeres dokument kan knitte - i selve eksamen afleverer du et html dokument. Lav et nyt R Markdown-dokument og fjern eksempelkoden. Husk at oprette en ny chunk ved at trykke på “Insert” ny chunk” eller bruge genvejstastene CMD+ALT+I eller CTRL+ALT+I. Jeg anbefaler at oprette en ny chunk for hver plot, I laver. Vi bruger datasættet diamonds. Husk at først indlæse dataene: data(diamonds) Her er beskrivelsen af diamonds: Prices of over 50,000 round cut diamonds: a dataset containing the prices and other attributes of almost 54,000 diamonds. Se også ?diamonds for en beskrivelse af variablerne. 2) Brug datasættet diamonds til at lave et scatter plot (geom_point()): caret på x-aksen price på y-aksen Så at du har noget at sammenligne med, skal dit plot se sådan ud: 3) Tilføj følgende komponenter til dit plot fra 2): En x-akse label (xlab()) og en y-akse label (ylab()) En titel (ggtitle()) Et tema som hedder theme_bw() Husk at forbinde komponenterne med + og skriv de nye komponenter på deres egen linje. Det skal se sådan ud: 4) Ændr temaet på dit plot til theme_classic() eller theme_minimal() i stedet for theme_bw() og se på resultatet. Hvis man (måske ved et uheld) skriver to temaer på samme tid (f.eks. + theme_bw() + theme_classic()), hvilket tema vil så blive anvendt i plottet? Valgfri ekstra: her er nogle flere temaer, du kan prøve: https://ggplot2.tidyverse.org/reference/ggtheme.html 5) Lav det samme plot som i 3), og skriv color=color ind i aes(). Den første color refererer til punkt farver og den anden til variablen color i dataframen. Det skal se sådan ud: Nu fjern color=color fra funktionen aes() og i stedet tilføj aes(color=color) i funktionen geom_point(). Får du samme resultat? Bemærk at det er lige meget om man bruger britisk eller amerikansk stavning i ggplot2 - fk. colour eller color ind i aes() giver samme resultat. 6) Brug stadig diamonds, til at lave et boxplot: cut på x-aksen (giv x-aksen label Cut) price på y-aksen (giv y-aksen label Price of diamond) bruge fill til at give forskellige farver til de mulige værdier af cut. bruge temaet theme_bw() Det skal se sådan ud: Hvordan ser det ud, hvis man bruger colour i stedet for fill? Eller hvis man specificerer begge to? 7) Lav følgende ekstra ændringer til din boxplot fra ovenstående: Tilføj geom_jitter() til din boxplot fjern legend ved at tilføj theme(legend.position=\"none\") Man kan også tilføj show.legend=FALSE til både geom_boxplot() og geom_jitter() i stedet for - prøv det i stedet for at bruge theme(legend.position=\"none\"). Er det nok at tilføje show.legend=FALSE til kun én af de to geoms? Det skal se sådan ud: Man kan også prøve at forbedre plottet ved at give nogle indstillinger ind i geom_jitter(), for eksempel kan man prøve geom_jitter(size=.2,color=\"grey\",alpha=0.5) for at gøre punkter mindre overbelastende i plottet (eller kan man overvejer at fjerne dem). Leg med de tre indstillinger size, color og alpha og se på forskellen. Her er en note om alpha: Alpha refers to the opacity of a geom. Values of alpha range from 0 to 1, with lower values corresponding to more transparent colors. https://ggplot2.tidyverse.org/reference/aes_colour_fill_alpha.html Prøv at skifte rækkefølgerne af geom_jitter() og geom_boxplot() i dit plot kommando og se - gøre det en forskel til, hvordan plottet ser ud? 8) Lav en barplot med indstillingen stat=\"count\": Variablen clarity på x-aksen Forskellige farver til gruppevariablen cut Specificer position=\"dodge\" for at få bars ved siden af hinanden Brug også indstillingen color=\"black\" og noter effekten Tilføj et tema. 9) Lav en histogram Variablen depth på x-aksen Forskellige farver til gruppevariablen cut Brug indstilling alpha til at ændre gennemsigtigheden af søljerne Giv søjlerne en sort ramme Tilføj et tema osv. Det ser sådan ud: Nu får du en advarsel - gør hvad advarselen siger og ændre på parameteren bins ind i geom_histogram()-funktionen. 10) Lav et density plot: Det kan være svært at sammenligne fordelingerne i de tidligere oprettede histograms. Erstat geom_histogram med geom_density i din kode fra 9). Er det nu lettere at sammenligne fordelingerne efter de forskellige niveauer af cut? Tilføj lodrette linjer med beregnede medianværdier af variablen depth for hver af de cut-niveauer. Hint: Brug tapply til at beregne medianværdierne og geom_vline til at tilføje lodrette linjer. 11) Lav et line plot. Åbn datsættet BOD: data(BOD) #BOD: This dataset contains the biochemical oxygen demand (BOD) of water samples taken at different time points. Lav et line plot (geom_line()) variablen Time på x-aksen variablen demand på y-aksen vælg selv ettiketter, title og tema 12 Lav et line plot (geom_line()) Åbn datasættet CO2: data(CO2) Lav en delmængde til typen “Quebec” (variablen Type): CO2_subset &lt;- CO2[CO2$Type==&quot;Quebec&quot;,] Brug din delmængde til at lave et line plot med variablen conc på x-aksen, variablen uptake. Dit plot bør have seks linjer (en til hver Plant) og linjerne farves efter behandlingsmetode (variablen Treatment). 13) En ekstra øvelse: Leg frit med at lave andre plots fra diamonds med ggplot2. For eksempel: Boxplots med carat opdelt efter clarity. Barplots for de forskellige farver (variable color). Et scatter plot af depth vs price. I alle tilfælde, tilføj akse-labels, en titel, et tema osv. 3.11 Næste gang Efter at have lavet disse øvelser vil man kunne se, at der er rigtig meget fleksibilitet involveret i at lave et plot med ggplot2. Næste lektion vil vi fortsætte med andre plot-typer og lære, hvordan man manuelt kan vælge farver. "],["visual2.html", "Chapter 4 Visualisering - ggplot2 dag 2 4.1 Indledning og videoer 4.2 Koordinat systemer 4.3 Mere om farver og punkt former 4.4 Annotations (geom_text) 4.5 Adskille plots med facets (facet_grid/facet_wrap) 4.6 Gemme dit plot 4.7 Problemstillinger", " Chapter 4 Visualisering - ggplot2 dag 2 4.1 Indledning og videoer I det nuværende emne udvider du værktøjskassen af kommandoer i pakken ggplot2, så at du kan opnå større fleksibilitet og appel i dine visualiseringer. Jeg anbefaler, at du bruger notaterne som en form for reference samtidig at du arbejder med problemstillingerne. 4.1.1 Læringsmålene I skal være i stand til at: Arbejde fleksibelt med koordinatsystemer - transformere, modificere og “flippe” x- og y-aksen. Udvide brugen af farver og former. Tilføje tekst direkte på plottet ved hjælpe af geom_text(). Bruge facet_grid() eller facet_wrap() til at opdele plots efter en katagorisk variabel. Gemme dit færdige plot i en fil. library(ggplot2) #husk 4.1.2 Video ressourcer Video 1: Koordinat systemer (2021) Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/544201985 Video 2: Farver og punkt former (2021) Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/544218153 Video 3: Labels - geom_text() og geom_text_repel() (2021) Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/544226498 Video 4 - Facets Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/704140333 4.2 Koordinat systemer Her arbejder vi videre med koordinater i pakken ggplot2. 4.2.1 Zoom (coord_cartesian(), expand_limits()) Man kan bruge funktionen coord_cartesian() til at zoome ind på et bestemt område på plottet. Indenfor coord_cartesian() angives xlim() og ylim(), som specificerer de øvre og nedre grænser langs henholdsvis x-aksen og y-aksen. Man kan også bruge xlim() og ylim() uden om coord_cartesian(), men i dette tilfælde bliver punkterne, som ikke kan ses i plottet (fordi deres koordinater ligger udenfor de angivne grænser), smidt væk (med en advarsel). Med coord_cartesian() beholder man til gengæld samtlige data, og man får således ikke en advarsel. Nedenfor ses vores oprindelige scatter plot: ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width,color = Species)) + geom_point() + theme_minimal() Og her anvender jeg funktionen coord_cartesian() med xlim() og ylim() indenfor til at zoome ind på et ønsket område på plottet. ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width,color = Species)) + geom_point() + coord_cartesian(xlim = c(4,6), ylim = c(2.2,4.5)) + theme_minimal() Du kan også zoome ud ved at bruge expand_limits(). For eksempel, hvis jeg gerne vil have punkterne \\(x = 0\\) og \\(y = 0\\) (c(0,0), eller “origin”) med i selve plottet: ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,col=Species)) + geom_point() + expand_limits(x = 0, y = 0) + theme_minimal() Det kan være brubart i situationer, hvor man for eksempel har flere etiketter omkring punkterne i selve plottet, som bedre kan ses, hvis man tillader lidt ekstra plads i plottets område. 4.2.2 Transformering af akserne - log, sqrt osv (scale_x_continuous). Nogle gange kan det være svært at visualisere visse variabler på grund af deres fordeling. Hvis der er mange outliers i variablen, vil de fleste punkter samles i et lille område i plottet. Transformering af x-aksen og/eller y-aksen med enten log eller sqrt er især en populær tilgang, så dataene kan ses på en mere informativ måde. ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,col=Species)) + geom_point(size=3) + scale_x_continuous(trans = &quot;log2&quot;) + scale_y_continuous(trans = &quot;log2&quot;) + theme_minimal() Man kan også prøve at bruge “sqrt” i stedet for “log2”. Formålet er, at hvis dataene fordeler sig mere normalt, kan de nemmere visualiseres i et plot ved at transformere dem med enten “sqrt” eller “log2”. Det er dog vigtigt at bemærke, at dette er forskelligt fra at transformere selve dataene, som bruges i plottet. Jeg kan for eksempel opnå det samme resultat ved at ændre datasættet, før jeg anvender ggplot2. Her behøver jeg ikke at bruge scale_x_continuous(trans = \"log2\"), men jeg bemærker, at tallene på akserne reflekterer de transformerede data og ikke de oprindelige værdier. Beslutningen afhænger af, hvad man gerne vil opnå med analysen af dataene. iris$Sepal.Length &lt;- log2(iris$Sepal.Length) iris$Sepal.Width &lt;- log2(iris$Sepal.Width) ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width,col=Species)) + geom_point(size=3) + theme_minimal() 4.2.3 Flip coordinates (coord_flip) Vi kan bruge coord_flip() til at spejle x-aksen på y-aksen og omvendt (det svarer til at drejer plottet 90 grader). Se følgende eksempel, hvor jeg først opretter variablen Sepal.Group, laver en barplot og anvender coord_flip for at få søjlerne til at stå vandret. #Sepal.Group defineret som i går iris$Sepal.Group &lt;- ifelse(iris$Sepal.Length&gt;mean(iris$Sepal.Length),&quot;Long&quot;,&quot;Short&quot;) ggplot(iris,aes(x=Species,fill=Sepal.Group)) + geom_bar(stat=&quot;count&quot;,position=&quot;dodge&quot;,color=&quot;black&quot;) + coord_flip() + theme_minimal() Man kan ændre rækkefølgen af de tre Species ved at bruge funktionen scale_x_discrete() og angive den nye rækkefølge med indstillingen limits: ggplot(iris,aes(x=Species,fill=Sepal.Group)) + geom_bar(stat=&quot;count&quot;,position=&quot;dodge&quot;,color=&quot;black&quot;) + coord_flip() + scale_x_discrete(limits = c(&quot;virginica&quot;, &quot;versicolor&quot;,&quot;setosa&quot;)) + theme_minimal() 4.3 Mere om farver og punkt former Der er flere måder at specificere farver på i ggplot2. Man kan nøjes med den automatiske løsning, som er hurtig (og effektiv i mange situationer), eller man kan bruge den manuelle løsning, som tager lidt længere tid at kode, men er brugbar, hvis man gerne vil lave et plot til at præsentere for andre. 4.3.1 Automatisk farver Vi i det sidste emne, at man automatisk kan få forskellige farver ved at benytte colour=Species indenfor aes() i den ggplot() funktion. #automatisk løsning ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) + geom_point() + theme_minimal() 4.3.2 Manuelle farver Hvis man foretrækker at bruge sine egne farver, kan man gøre det ved at benytte funktionen scale_colour_manual(). Her angiver man stadig colour=Species indenfor aes(), men man angiver derefter, hvilke bestemte farver de forskellige arter skal have indenfor scale_colour_manual, med indstillingen values. #manuelt løsning ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) + scale_colour_manual(values=c(&quot;purple&quot;, &quot;yellow&quot;,&quot;pink&quot;)) + geom_point() + theme_minimal() En fantastisk pakke er RColorBrewer. Pakken indeholder mange forskellige “colour palettes”, det vil sige grupper af farver, der passer godt sammen. Man kan derfor slippe for selv at skulle sammensætte en farvekombination, der passer til plottet. Nogle af farvepaletterne tager også hensyn til, om man er farveblind, eller om man ønsker en farvegradient eller et sæt diskrete farver, som ikke ligner hinanden. I følgende eksempel indlæser jeg pakken RColorBrewer og anvender funktionen scale_colour_brewer med indstillingen palette=\"Set1\": #install.packages(&quot;RColorBrewer&quot;) library(RColorBrewer) #manuelt løsning ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) + scale_colour_brewer(palette=&quot;Set1&quot;) + geom_point() + theme_minimal() Bemærk, at både scale_color_manual() og scale_color_brewer() bruges til at sætte farver på punkter og linjer, mens man i sammenhænge med boxplots eller barplots bruger scale_fill_manual() eller scale_fill_brewer() til at sætte farver på de udfyldte områder. For eksempel vil jeg i følgende eksempel gerne sætte farver på de udfyldte områder i en boxplot: ggplot(iris,aes(x=Species,y=Sepal.Length,fill=Species)) + geom_boxplot() + scale_fill_brewer(palette=&quot;Set2&quot;) + theme_minimal() Her er en oversigt over de fire funktioner: Funktion Beskrivelse scale_fill_manual(values=c(\"firebrick3\",\"blue\")) Bruges til manuelle farver i forbindelse med boxplots og barplots mv. scale_color_manual(values=c(\"darkorchid\",\"cyan4\")) Bruges til manuelle farver i forbindelse med punkter og linjer mv. scale_fill_brewer(palette=\"Dark2\") Bruger farvepaletter fra RColorBrewer i forbindelse med boxplots, barplots mv. scale_color_brewer(palette=\"Set1\") Bruger farvepaletter fra RColorBrewer i forbindelse med punkter og linjer mv. Der er også andre muligheder, hvis man har behov for dem - for eksempel kan man google efter scale_fill_gradient til kontinuerte data. Farver i RColourBrewer Her er en nyttig reference, der viser de forskellige farver tilgængelige i pakken RColourBrewer. Mulige colour palettes tilgængelige i RColourBrewer 4.3.3 Punkt former Ligesom man kan lave forskellige farver, kan man også lave forskellige punktformer. Vi starter med den automatiske løsning ligesom vi gjorde med farver. Når det er en variabel, vi angiver, skal variabelnavnet skrives indenfor aes(). Her, da shape er en parameter, der er meget specifik for geom_point, vælger jeg at skrive en ny aes() indenfor geom_point() i stedet for indenfor funktionen ggplot(). Husk, at man i funktionen ggplot() specificerer globale ting, der gælder for hele plottet, mens man i funktionen geom_point() angiver ting, der kun gælder for geom_point(). Se følgende eksempel: ggplot(data=iris, aes(x = Sepal.Length, y = Sepal.Width)) + scale_color_brewer(palette=&quot;Set2&quot;) + geom_point(aes(shape=Species)) + theme_minimal() Nu har jeg fået både en farve og en punkt form til hver art i variablen Species. Sætte punkt form manuelt Hvis vi ikke kan lide de tre automatiske punktformer, kan vi ændre dem ved at bruge scale_shape_manual. Her vælger jeg for eksempel values=c(1,2,3), men der er en reference nedenfor, hvor du kan se, mappingen mellem de numeriske tal og punktformer, så du kan vælge dine egne. ggplot(data=iris, aes(x = Sepal.Length, y = Sepal.Width, colour=Species)) + geom_point(aes(shape=Species)) + scale_color_brewer(palette=&quot;Set2&quot;) + scale_shape_manual(values=c(1,2,3)) + theme_minimal() Reference for punkt former Her er reference-tabellen for forskellige punktformer i ggplot2: 4.4 Annotations (geom_text) 4.4.1 Tilføjelse af labels direkte på plottet. Man kan bruge geom_text() til at tilføje tekst på punkterne direkte på plottet. Her skal man fortælle, hvad teksten skal være - i dette tilfælde specificerer vi navnene på biler fra datasættet mtcars. Plottet er et scatterplot mellem variablerne mpg og wt. data(mtcars) mtcars$my_labels &lt;- row.names(mtcars) #take row names and set as a variable ggplot(mtcars,aes(x=mpg,y=wt)) + geom_point() + geom_text(aes(label=my_labels)) + theme_minimal() For at gøre det nemmere at læse kan man også fjerne selve punkterne: ggplot(mtcars,aes(x=mpg,y=wt)) + #geom_point() + geom_text(aes(label=my_labels)) + theme_minimal() Teksten på plottet kan stadig være svær at læse. En god løsning kan være at bruge R-pakken ggrepel, som vist i følgende eksempel: 4.4.2 Pakken ggrepel for at tilføje tekst labeller #install.packages(ggrepel) #installere hvis nødvendeigt For at anvende pakken ggrepel på datasættet mtcars, skal man blot erstatte geom_text() med geom_text_repel(): library(ggrepel) ggplot(mtcars,aes(x=mpg,y=wt)) + geom_point() + geom_text_repel(aes(label=my_labels)) + theme_minimal() ## Warning: ggrepel: 9 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps Nu kan vi se, at der ikke er nogen labels, som sidder lige overfor hinanden, fordi ggrepel() har været dygtig nok til at placere dem tæt på deres tilhørende punkter, og ikke ovenpå hinanden. Der er også nogle punkter, hvor funktionen har tilføjet en linje for at gøre det klart, hvilken punkt teksten refererer til. Vi har dog fået en advarsel i ovenstående kode. Hvis vi vil undgå denne advarsel, kan vi specificere max.overlaps = 20. library(ggrepel) ggplot(mtcars,aes(x=mpg,y=wt)) + geom_point() + geom_text_repel(aes(label=my_labels),max.overlaps = 20) + theme_minimal() Nu kan du se, at du ikke længere får en advarsel, og der er tilføjet tekst til alle punkterne. 4.4.3 Tilføjelse af rektangler i regioner af interesse (annotate) Hvis man gerne vil fremhæve et bestemt område i plottet, kan man bruge funktionen annotate(). Prøv selv at regne ud, hvad de indstillinger inden for annotate() betyder i følgende eksempel: ggplot(mtcars,aes(x=mpg,y=wt)) + geom_point() + geom_text_repel(aes(label=my_labels)) + annotate(&quot;rect&quot;,xmin=18,xmax=23,ymin=2.5,ymax=3,alpha=0.2,fill=&quot;orange&quot;) + theme_minimal() ## Warning: ggrepel: 9 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps Man kan også benytte den samme funktion til at tilføje tekst på et bestemt sted: ggplot(mtcars,aes(x=mpg,y=wt)) + geom_point() + geom_text_repel(aes(label=my_labels)) + annotate(&quot;rect&quot;,xmin=18,xmax=23,ymin=2.5,ymax=3,alpha=0.2,fill=&quot;orange&quot;) + annotate(&quot;text&quot;,x=25,y=2.75,label=&quot;Cars of interest&quot;,col=&quot;orange&quot;) + theme_minimal() ## Warning: ggrepel: 9 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps 4.5 Adskille plots med facets (facet_grid/facet_wrap) En stor fordel ved at bruge ggplot er evnen til at bruge funktionerne facet_grid() og facet_wrap() til at adskille efter en kategorisk variabel over flere plots. I følgende kode viser jeg et density plot, hvor de tre kurver, der tilhører de tre arter, ligger oven på hinanden i det samme plot: ggplot(iris,aes(x=Sepal.Length,fill=Species)) + geom_density(alpha=0.5) + theme_minimal() Med funktionerne facet_grid() eller facet_wrap() bruger vi ~ (tilde) til at angive, hvordan vi gerne vil visualisere de forskellige plots. Vi skal angive, om vi ønsker at opdele dem over rækker (variablerne venstre for ~) eller over kolonner (variablerne til højre for ~). #notrun variable(s) to split into row-wise plots ~ variables(s) to split into column-wise plots Ovenstående density plots af Sepal.Length kan adskilles efter Species, således at man får tre plots med en kolonne til hver af de tre arter ved hjælp af facet_wrap() funktionen: ggplot(iris,aes(x=Sepal.Length,fill=Species)) + geom_density(alpha=0.5) + facet_grid(~Species) + #split Species into different column-wise plots theme_minimal() Man kan også vælge at adskille plotsne over rækkerne ved hjælp af facet_wrap(). Her skal man dog huske at bruge en . efter ~ for at betegne, at man kun vil adskille plots over rækkerne, mens man af en eller anden grund kan droppe . hvis man kun vil adskille over kolonner som i det foregående eksempel. ggplot(iris,aes(x=Sepal.Length,fill=Species)) + geom_density(alpha=0.5) + facet_grid(Species~.) + #split Species into different column-wise plots theme_minimal() Her angives Sepal.Group ~ Species, hvilket betyder, at plotterne bliver adskilt efter både Sepal.Group og Species - Sepal.Group over rækkerne og Species over kolonnerne - ved hjælp af facet_grid() funktionen: ggplot(iris,aes(x=Sepal.Length,fill=Species)) + geom_density(alpha=0.5) + facet_grid(Sepal.Group~Species) + #split Species into different column-wise plots theme_minimal() Bemærk forskellen mellem facet_grid() og facet_wrap(): #same plot, replace facet_grid with facet_wrap ggplot(iris,aes(x=Sepal.Length,fill=Species)) + geom_density(alpha=0.5) + facet_wrap(Sepal.Group~Species) + theme_minimal() I facet_grid() bliver man tvunget til at få et “grid” layout. Vi har således 6 plot i en 2 x 3 grid (2 niveauer for variablen Sepal.Group og 3 niveauer for variablen Species), og det sker selvom den ene af dem ikke har nogen data - der findes altså ikke observationer, hvor Species er “Setosa” og Sepal.Group er “Long”, men vi får et plot alligevel for at bevare strukturen. Med facet_wrap() bliver plot uden data droppet, og i dette tilfælde får man 5 plot i, hvad der kaldes en “ribbon”. Med facet_wrap() kan man også angive antallet af rækker og kolonner man vil have for plotterne. For eksempel kan man angive nrow = 1 eller ncol = 5 for at få alle fem plots på en række. ggplot(iris,aes(x=Sepal.Length,fill=Species)) + geom_density(alpha=0.5) + facet_wrap(Sepal.Group~Species,nrow = 1) + theme_minimal() Til sidst kan det være, at jeg gerne vil frigøre skalaen på y-aksen. På den måde har ikke alle plot de samme maksimale y-værdier, og de enkelte plot benytter i stedet egne værdier til at bestemme skalaen. Det kan være brugbart, hvis man inddrager forskellige målinger, men vær dog opmærksom på, hvad der bedst giver mening - hvis man direkte vil sammenligne to af plotterne, så er det bedre, at de deler samme y-akseskala. #same plot, replace facet_grid with facet_wrap ggplot(iris,aes(x=Sepal.Length,fill=Species)) + geom_density(alpha=0.5) + facet_wrap(Sepal.Group~Species,ncol = 5,scales = &quot;free&quot;) + theme_minimal() Jeg håber, det er klart, at disse funktioner er meget brugbare, og selvom de opnår stort set samme resultat, er der små forskelle mellem dem, som det er værd at huske. 4.6 Gemme dit plot Her bruger vi R Markdown til at lave en rapport, som indeholder vores plots, men det kan også være, at man gerne vil gemme sit plot som en fil på computeren. Til at gemme et plot kan man bruge kommandoen ggsave(): ggsave(myplot, &quot;myplot.pdf&quot;) Figuren vil blive gemt i din working directory (eller den mappe, hvor din .Rmd fil ligger). Filtypen .pdf kan erstattes med andre formater, f.eks. .png eller .jpeg. Hvis man gerne vil redigere sit plot (f.eks. i Adobe Illustrator eller Inkscape), vil jeg anbefale at gemme det som .pdf. Man må gerne ændre højden og bredden på det gemt plot med width og height: ggsave(myplot, &quot;myplot.pdf&quot;, width = 4, height = 4) 4.7 Problemstillinger Problem 1) Lav quiz - “Quiz - ggplot2 part 2” Problem 2) (Factorer og plots) a) Åbn datasættet mtcars og lav en barplot: Brug variablen cyl på x-aksen og tildele forskellige farver til de forskellige niveauer af samme variablen. Fungerer din kode? Tjek x-aksen. Variablen er numerisk, men skal fortolkes som en faktor. Konverter variablen til en faktor (eller bare skriv as.factor(cyl) i selve plottet) og lav dit plot igen. b) Opdel søjlerne ved at angive farver efter variablen gear i dit plot (søjlerne skal sidde ved siden af hinanden). Vær OBS på, hvordan R fortolker variablen. ggplot(data = mtcars, aes(x = cyl,fill = (gear))) + geom_bar(stat=&quot;count&quot;,position=&quot;dodge&quot;) + theme_minimal() ## Warning: The following aesthetics were dropped during statistical transformation: fill ## ℹ This can happen when ggplot fails to infer the correct grouping structure in ## the data. ## ℹ Did you forget to specify a `group` aesthetic or to convert a numerical ## variable into a factor? I følgende spørgsmål arbejder du med datasættet Palmer Penguins. Pakken palmerpenguins skal installeres hvis du ikke har brugt datasættet før. Data beskrivelse: The palmerpenguins data contains size measurements for three penguin species observed on three islands in the Palmer Archipelago, Antarctica. #install.packages(&quot;palmerpenguins&quot;) #køre hvis ikke allerede installeret library(palmerpenguins) library(ggplot2) library(tidyverse) head(penguins) FALSE # A tibble: 6 × 8 FALSE species island bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex year FALSE &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; FALSE 1 Adelie Torgersen 39.1 18.7 181 3750 male 2007 FALSE 2 Adelie Torgersen 39.5 17.4 186 3800 fema… 2007 FALSE 3 Adelie Torgersen 40.3 18 195 3250 fema… 2007 FALSE 4 Adelie Torgersen NA NA NA NA &lt;NA&gt; 2007 FALSE 5 Adelie Torgersen 36.7 19.3 193 3450 fema… 2007 FALSE 6 Adelie Torgersen 39.3 20.6 190 3650 male 2007 FALSE # … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g Man kan altid anvende ?penguins for at se flere detaljer om variablenavner. Vi skal starte med at rydde op lidt i datasættet. Køre følgende for at fjerne al rækker som har NA (manglende) værdier (her skal man have tidyverse-pakken indlæste): penguins &lt;- drop_na(penguins) Problem 3) Manuelt farver og punkter a) Lav et scatter plot med ggplot()-funktionen: bill_length_mm på x-aksen bill_depth_mm på y-aksen giv hver art (variablen species) sin egen farve (brug den automatiske løsning) sæt et tema b) Lav følgende ændringer til dit plot fra a): Ændr farver manuelt - prøv både at angive farver med scale_color_manual() og afprøve også løsningen med pakken RColorBrewer (husk at installere/indlæse pakken, hvis nødvendigt). Brug forskellige punkt-former til hver art i variablen species. Prøv også at vælge nogle punkt-former fra listen (i kursusnotaterne) og specificer dem manuelt. Figure 4.1: Min løsning Problem 4) Koordinatsystemer Tag udgangspunkt i overstående scatter plot fra 3) og a) brug coord_cartesian(), så kun pingviner med en bill længde (variablen bill_length_mm) mellem 40 og 50 og en bill depth (variablen bill_depth_mm) mellem 16 og 19 er medtaget på plottet. b) brug pakken ggrepel (husk at installere/indlæse) og tilføj navnene på de forskellige øer som tekst direkte på plottet c) lav en delmængde af datasættet penguins efter samme betingelser som i a) og specificer din nye dataframe som parameteren data indenfor geom_text_repel()-funktionen. Dette undgår, at tekst bliver plottet for punkter udenfor området angivet med coord_cartesian(). ## Warning: ggrepel: 14 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps Figure 4.2: Min løsning Problem 5) Histogram med facets Lav et histogram: Variablen flipper_length_mm på x-aksen Anvend facet_grid for at adskille dit plot i tre efter variablen species Giv også en forskellig farve til hver art i species Hvis nødvendigt, ændr parameteren bins til noget andet indenfor geom_histogram(). Her er min løsning: Problem 6) a) Lav et density plot af body_mass_g. Anvend funktionen facet_grid til at lave tre plots, en til hver art i variablen species Brug også fill til at opdele hver af dine tre density kurver efter variablen sex (dvs. du har stadig 3 plots, og hvert plot har to density kurver) Gør dine density plots gennemsigtige Skriv en sætning om forskellen i body_mass_g mellem “females” og “males”. b) Nu udvikl din facet_grid kommando til at adskille plots yderligere således at du har en “grid” struktur med de forskellige øer (variablen island) på rækkerne og de tre arter (variablen species) på kolonnerne. c) Kan du forklare, hvorfor der er blanke plots i din grid? Eksperimenter med facet_wrap i stedet for facet_grid. Problem 7) Koordinatsystemer Lav et søjlediagram af antallet for species opdelt efter sex. Anvend en ‘coordinate flip’ for at få den til at være vandret/horizontal. Vælg nogle farver - jeg benytter palette = \"Accent\" fra RColorBrewer løsningen Ændr rækkefølgen af de tre søjler, således at arten med flest observationer er øverst, og arten med færrest er nederst. Prøv også at tilføje scale_y_reverse() og kig på resultatet. Her er min løsning: Figure 4.3: Min løsning Problem 8) Lav boxplots af body_mass_g opdelt efter species. Tilføj “jitter” punkter ovenpå boksplot. Specificer nogle farver manuelt for både bokse og punkterne (en farve til hver art) Giv det en passende titel og nogle akse-etiketter Tilføj en ny variabel island_binary til penguins, som er “Biscoe” hvis island er ‘Biscoe’ og “not Biscoe” hvis ikke. Adskil plotterne ved at opdele efter island_binary. Ekstra: prøv ?geom_violin som erstatning for geom_boxplot. Problem 9) Annotationer og linjer. a) Lav et scatterplot af bill_length_mm vs bill_depth_mm. Anvend passende titel/etiketter/tema Anvend forskellige farver for de tre species. Tjek funktionen ?annotate og brug den med geom=\"text\" og passende x- og y-akse værdier til at tilføje species navne som tekst direkte på plottet (se eksempel nedenfor for at se, hvad jeg mener). Udforsk, hvordan man gør teksten større, som jeg har gjort i min løsning. Fjern legenden med show.legend = FALSE indenfor geom_point() Her er min løsning: b) Vi vil gerne tilføje nogle lodrette og vandrette linjer til plottet, som viser gennemsnitsværdierne for variablerne for de tre arter. Først skal du bruge tapply til at beregne de gennemsnitlige værdier for henholdsvis bill_length_mm og bill_depth_mm opdelt efter species (gem dem som henholdsvis mean_length og mean_depth). Brug mean_length og mean_depth til at tilføje linjer til plottet med den relevante funktion. c) Kan du tilpasse linjerne så deres farver matcher punkterne for deres respektive art (se min løsning nedenfor)? Der er sikkert mange måder at gøre det på, men hvis du har brug for en hint, kan du kigge nedenunder: Hint: start med følgende dataframe, der bruger dine beregnede værdier: mydf &lt;- data.frame(&quot;species&quot;=names(mean_length), &quot;mlength&quot;=mean_length, &quot;mdepth&quot;=mean_depth) mydf ## species mlength mdepth ## Adelie Adelie 38.82397 18.34726 ## Chinstrap Chinstrap 48.83382 18.42059 ## Gentoo Gentoo 47.56807 14.99664 Angiv parameteren data til at være ovenstående dataframe i geom_vline() og brug lokal æstetik (aes()) til at angive parametre til linjerne. Gør det samme for geom_hline() Specificer også “stiplede” linjer Her er min løsning: Figure 4.4: min løsning Problem 10) Ekstra. Kig på “cheatsheet” for ggplot2 (klik på “Help” &gt; “Cheatsheets” og vælg den for ggplot2) og afprøv nogle af de ting, som ikke er blevet dækket i kurset indtil videre! Jeg vil gerne høre, hvis du finder noget meget nyttigt for dig, som ellers er blevet glemt i notaterne. "],["data.html", "Chapter 5 Bearbejdning dag 1 5.1 Hvad er Tidyverse? 5.2 Video ressourcer 5.3 Oversigt over pakker 5.4 Principper for ‘tidy data’ 5.5 Lidt om tibbles 5.6 Transition fra base-R til tidyverse 5.7 Bearbejdning af data: dplyr 5.8 Visualisering: bruge som input i ggplot2 5.9 Misc funktioner som er nyttige at vide 5.10 Problemstillinger 5.11 Kommentarer", " Chapter 5 Bearbejdning dag 1 5.1 Hvad er Tidyverse? Tidyverse er en samling af pakker i R, som man bruger til at bearbejde datasæt. Formålet er ikke nødvendigvis at erstatte funktionaliteten af base-pakken, men til at bygge videre på den. Som vi vil se i detaljer, deler tidyverse faktisk mange af de samme principper som ggplot2 - men i stedet for at bruge + til at opbygge komponenter i et plot, bruger man %&gt;% (udtales ‘pipe’) til at kæde forskellige funktioner sammen. Most common tidyverse packages Læringsmålene til i dag I skal være i stand til at: Beskrive generelt, hvad R-pakken Tidyverse kan bruges til. Beskrive en tibble og genkende når et datasæt er betragtet som “tidy”. Benytte nogle vigtige Tidyverse-verbs til at bearbejde data (filter(),select(), mutate(), rename(), arrange(), recode()). Bruge %&gt;% til at forbinde Tidyverse-verber sammen og at overføre data til et plot. 5.2 Video ressourcer __Begynd med at læse “Principper for ‘tidy data’” og “Lidt om tibbles” nedenfor og derefter se følgende videoer. Video 1 - rydde op i datasættet titanic med select() og drop_na() Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/706266697 Video 2 - tidyverse verber: select og filter Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/705136725 Video 3 - flere tidyverse verber Lave en ny kolon med mutate() Ændre variabelnavne med rename() Ændre på værdierne med recode() Ændre rækkefølgen af observationerne med arrange() Bruge tidyverse kommandoer som input i ggplot2() Link her hvis det ikke virker nedenunder: https://player.vimeo.com/video/706266885 5.3 Oversigt over pakker Lad os starte med at indlæse pakken tidyverse. Vær opmærksom på, at hvis du ikke allerede har pakken på din computer, kan det tage lidt tid at installere den da tidyverse er afhængig af mange andre pakker, som også skal installeres eller opdateres. Hvis du allerede har pakken installeret, men oplever problemer, skal du tjekke, om du har det seneste version af pakkerne og R på dit system. #install.packages(&quot;tidyverse) library(tidyverse) Du kan se, at der faktisk ikke kun er én, men otte pakker, der er blevet indlæst. Det er muligt at indlæse hver pakke individuelt ved at bruge fx library(dplyr), men det er meget bekvemt at indlæse dem alle på én gang ved at bruge library(tidyverse). Her er en kort beskrivelse af hver pakke: Pakke Kort beskrivelse readr Indlæsning af data ggplot2 Plotning af data tibble Oprettelse af “tibbles” - tidyverse’s svar på datarammer (data.frame). tidyr Transformation af data til forskellige formater (fx fra ‘long’ til ‘wide’ format eller omvendt) purrr Functional programming, gentagelse dplyr Manipulation af tibbles - udvælgelse af undergrupper, oprettelse af nye variabler, beregning af oversigtsstatistikker osv. stringr Manipulation af strenge (ikke brugt i dette kursus) forcats Håndtering af faktorvariabler (også kaldet “categories”) 5.4 Principper for ‘tidy data’ Idéen bag tidyverse er, at hvis alle datasæt følger præcis den samme struktur, så er det enkelt at bearbejde dem præcis som vi ønsker det. Datasæt med denne struktur kaldes “tidy data”. For at betragte et datasæt som “tidy” skal det opfylde tre kriterier: Hver variabel i datasættet har sin egen kolonne Hver observation i datasættet har sin egen række Hver værdi i datasættet har sin egen celle Et godt eksempel på et datasæt i tidy format er Iris-datasættet: data(iris) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa I datasættet har hver variabel (Sepal.Length, Sepal.Width, Petal.Length, Petal.Width og Species) sin egen kolonne, og hver observation (fx observation 1, 2, 3, osv.) har sin egen række. Derudover har hver celle sin egen værdi, hvilket gør datasættet meget læsbart og let at forstå ved blot at kigge på det. Principper af tidy data Det er tilfældet, at de fleste datasæt i dette kursus hører til kategorien “tidy data”, især i disse notater, hvor vi bruger en del af de indbyggede datasæt. Nogle gange er det dog nødvendigt at transformere et datasæt til “tidy data”. R-pakkerne dplyr og tidyr er velegnede til at hjælpe med at transformere et datasæt til “tidy data”, og derefter kan man analysere datasættet på sædvanlig vis. Bemærk dog, at bare fordi et datasæt er “tidy”, betyder det ikke nødvendigvis, at det er klar til analyse, da der stadig kan være behov for yderligere bearbejdning med pakkerne dplyr og tidyr. 5.5 Lidt om tibbles En tibble er tidyverse’s svar på en data.frame fra base-R. De ligner meget hinanden, og derfor behøver man ikke tænke så meget over forskellen. Men der er nogle opdaterede aspekter i en tibble. For eksempel bruger en tibble ikke row.names, og når man visualiserer en tibble i R Markdown, får man lidt ekstra oplysninger såsom dimensioner og datatyper. Det er vigtigt at bemærke, at de fleste tidyverse-funktioner fungerer lige så godt, uanset om man bruger en tibble eller en data.frame. Det er dog vigtigt at bemærke, at jeg vil bruge ordet “data frame” inden for almindelig tekst. Man kan oprette sin egen tibble på samme måde som en data.frame. tibble(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## # A tibble: 3 × 2 ## x y ## &lt;int&gt; &lt;chr&gt; ## 1 1 a ## 2 2 b ## 3 3 c Man kan også oprette en tribble, som er den samme som en tibble, men har en lidt anderledes måde at indsætte data på. For eksempel svarer følgende til den tidligere tibble: tribble(~x, ~y, 1, &quot;a&quot;, 2, &quot;b&quot;, 3, &quot;c&quot;) ## # A tibble: 3 × 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 2 b ## 3 3 c Man kan omdanne en data.frame til en tibble ved at bruge funktionen as_tibble(), som vist nedenfor: as_tibble(iris) ## # A tibble: 150 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # … with 140 more rows 5.6 Transition fra base-R til tidyverse Jeg introducerer tidyverse med et meget berømt datasæt kaldet Titanic. Det er ikke biologisk data, men det er stadig ret interessant og sjovt at arbejde med. Titanic-datasættet er blevet brugt som en del af en åben konkurrence på Kaggle, hvor mindst 31.000 personer hidtil har arbejdet på at lave den bedste model til at forudsige, hvem der overlever katastrofen. Du kan læse mere om baggrunden for datasættet og konkurrencen på dette link: https://www.kaggle.com/c/titanic. 5.6.1 Om Titanic datasættet Man kan downloade datasættet, der hedder titanic_train, direkte fra Kaggle. Men der er faktisk en R-pakke kaldet titanic, som gør det mere bekvemt: #install.packages(&quot;titanic&quot;) #hvis ikke allerede installerede library(titanic) Her er beskrivelsen for pakken: titanic is an R package containing data sets providing information on the fate of passengers on the fatal maiden voyage of the ocean liner “Titanic”, summarized according to economic status (class), sex, age and survival. These data sets are often used as an introduction to machine learning on Kaggle. Vi vil gerne bruge titanic_train-datasættet, fordi det er det datasæt, der bliver brugt på Kaggle til at træne maskinlæringsmodeller (som derefter bliver testet på titanic_test-datasættet for at evaluere, hvor god modellen er). For at gøre tingene nemmere, vil vi blot omdøbe titanic_train til titanic og bruge funktionen glimpse() fra dplyr-pakken til at se på datasættet. titanic &lt;- as_tibble(titanic_train) glimpse(titanic) ## Rows: 891 ## Columns: 12 ## $ PassengerId &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,… ## $ Survived &lt;int&gt; 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1… ## $ Pclass &lt;int&gt; 3, 1, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 2, 3, 3… ## $ Name &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Fl… ## $ Sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;mal… ## $ Age &lt;dbl&gt; 22, 38, 26, 35, 35, NA, 54, 2, 27, 14, 4, 58, 20, 39, 14, … ## $ SibSp &lt;int&gt; 1, 1, 0, 1, 0, 0, 0, 3, 0, 1, 1, 0, 0, 1, 0, 0, 4, 0, 1, 0… ## $ Parch &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0… ## $ Ticket &lt;chr&gt; &quot;A/5 21171&quot;, &quot;PC 17599&quot;, &quot;STON/O2. 3101282&quot;, &quot;113803&quot;, &quot;37… ## $ Fare &lt;dbl&gt; 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 8.4583, 51.8625,… ## $ Cabin &lt;chr&gt; &quot;&quot;, &quot;C85&quot;, &quot;&quot;, &quot;C123&quot;, &quot;&quot;, &quot;&quot;, &quot;E46&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;G6&quot;, &quot;C… ## $ Embarked &lt;chr&gt; &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;Q&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;… Jeg har også kopieret de variable beskrivelser her: PassengerId: unique index for each passenger Survived: Whether or not the passenger survived. 0 = No, 1 = Yes. Pclass: Ticket class: 1 = 1st Class, 2 = 2nd Class, 3 = 3rd Class. Name: A character string containing the name of each passenger. Sex: Character strings for passenger sex (“male”/ “female”). Age: Age in years. SibSp: The number of siblings/spouses aboard the titanic with the passenger Parch: The number of parents/children aboard the titanic with the passenger Ticket: Another character string containing the ticket ID of the passenger. Fare: The price paid for tickets in pounds Sterling (Keep in mind that unskilled workers made around 1 pound a week - these were expensive tickets!) Cabin: The cabin number of the passengers (character). Embarked: Where passengers boarded the titanic. C = Cherbourg, Q = Queenstown, S = Southampton). 5.6.2 Titanic: Rengøring Før vi kan fortsætte med analysen, er der nogle oprydninger, der skal foretages i datasættet. Vi kan se fra glimpse(titanic)-kommandoen, at der er 891 observationer. De fleste passagerer (687) har faktisk intet oplyst i variablen Cabin: sum(titanic$Cabin == &quot;&quot;) # antal observationer med ingenting for variablen &#39;Cabin&#39; ## [1] 687 Andre passagerer har mere end én cabin. Det ser ikke særlig tidy ud, og det er heller ikke særlig relevant for analysen, så vi vælger at fjerne hele kolonnen med funktionen select(): titanic_no_cabin &lt;- select(titanic, -Cabin) select() er en af de grundlæggende funktioner i tidyverse. Her angiver vi, hvilke kolonner vi ønsker at beholde eller fjerne fra datasættet. I dette tilfælde har vi specificeret -Cabin, hvilket betyder, at vi ikke ønsker at medtage variablen Cabin, men vi ønsker at beholde resten af kolonnerne. Prøv selv at køre select(titanic, Cabin) i stedet - så vil vi kun have variablen Cabin og fjerne resten af vores variabler. glimpse(titanic_no_cabin) ## Rows: 891 ## Columns: 11 ## $ PassengerId &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,… ## $ Survived &lt;int&gt; 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1… ## $ Pclass &lt;int&gt; 3, 1, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 2, 3, 3… ## $ Name &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Fl… ## $ Sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;mal… ## $ Age &lt;dbl&gt; 22, 38, 26, 35, 35, NA, 54, 2, 27, 14, 4, 58, 20, 39, 14, … ## $ SibSp &lt;int&gt; 1, 1, 0, 1, 0, 0, 0, 3, 0, 1, 1, 0, 0, 1, 0, 0, 4, 0, 1, 0… ## $ Parch &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0… ## $ Ticket &lt;chr&gt; &quot;A/5 21171&quot;, &quot;PC 17599&quot;, &quot;STON/O2. 3101282&quot;, &quot;113803&quot;, &quot;37… ## $ Fare &lt;dbl&gt; 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 8.4583, 51.8625,… ## $ Embarked &lt;chr&gt; &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;Q&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;… Næste skridt er at undersøge, om der er manglende værdier (NA) i datasættet. NA er, hvordan R betegner manglende værdier. Som det fremgår af følgende kode, har de fleste variabler ikke NA-værdier, men variablen Age har 177 NA-værdier. colSums(is.na(titanic_no_cabin)) ## PassengerId Survived Pclass Name Sex Age ## 0 0 0 0 0 177 ## SibSp Parch Ticket Fare Embarked ## 0 0 0 0 0 I dette tilfælde vælger jeg at fjerne alle passagerer, der mangler aldersoplysninger (NA) i stedet for at estimere eller imputere deres alder. Til dette formål bruger jeg funktionen drop_na, som fjerner alle observationer, der har NA i mindst én variabel. titanic_clean &lt;- drop_na(titanic_no_cabin) colSums(is.na(titanic_clean)) ## PassengerId Survived Pclass Name Sex Age ## 0 0 0 0 0 0 ## SibSp Parch Ticket Fare Embarked ## 0 0 0 0 0 Nu kan vi tjekke, hvor mange observationer og variabler, der er tilbage. glimpse(titanic_clean) ## Rows: 714 ## Columns: 11 ## $ PassengerId &lt;int&gt; 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19… ## $ Survived &lt;int&gt; 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1… ## $ Pclass &lt;int&gt; 3, 1, 3, 1, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 3, 2, 2, 3… ## $ Name &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Fl… ## $ Sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;mal… ## $ Age &lt;dbl&gt; 22, 38, 26, 35, 35, 54, 2, 27, 14, 4, 58, 20, 39, 14, 55, … ## $ SibSp &lt;int&gt; 1, 1, 0, 1, 0, 0, 3, 0, 1, 1, 0, 0, 1, 0, 0, 4, 1, 0, 0, 0… ## $ Parch &lt;int&gt; 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0… ## $ Ticket &lt;chr&gt; &quot;A/5 21171&quot;, &quot;PC 17599&quot;, &quot;STON/O2. 3101282&quot;, &quot;113803&quot;, &quot;37… ## $ Fare &lt;dbl&gt; 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 51.8625, 21.0750… ## $ Embarked &lt;chr&gt; &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;… Vi har beholdt 714 observationer og 11 variabler, og datasættet opfylder kravene for at være tidy. 5.6.3 Pipe Man kan faktisk opnå det samme som i ovenstående eksempel ved at bruge pipe %&gt;%: titanic_clean &lt;- titanic %&gt;% # vi tager titanic-datasættet select(-Cabin) %&gt;% # udvælger de ønskede kolonner drop_na() # fjerner alle observationer med manglende værdier Man bruger pipe %&gt;% til at kombinere adskillige Tidyverse-funktioner i samme kommando. Linjen slutter med %&gt;%, som fortæller, at vi skal bruge resultatet fra den foregående linje som input i den næste linje. Logikken er således, at vi starter med en dataframe, gør én ting ad gangen og slutter med en ny dataframe (som vi kan gemme med &lt;-). Bemærk, at denne proces ligner den, man bruger i ggplot2, men forskellen er, at man bruger %&gt;% i stedet for + i denne sammenhæng. Bemærk også, at jeg som i ggplot2 skriver koden over flere linjer. Det er ikke et krav, men det gør det nemmere at læse og forstå koden. For at illustrere logikken kan man se, at følgende to linjer er tilsvarende: #tag x og anvend en funktion f f(x) #traditionelt tilgang x %&gt;% f #tidyverse tilgang I begge tilfælde starter vi med x og anvender derefter funktionen f på x. En stor fordel ved den tidyverse-tilgangen er, at når man har flere funktioner, undgår man at skulle bruge mange parenteser, og rækkefølgen, som funktionerne anvendes i, læses fra venstre mod højre i stedet for omvendt, som i følgende eksempel: #tag x, anvend f, så g og til sidst h h(g(f(x))) #traditionelt tilgang x %&gt;% f %&gt;% g %&gt;% h #tidyverse tilgang På samme måde som i vores oprydning af titanic kan man både inkludere funktionen select() i drop_na() eller bruge tidyverse-tilgangen, som i følgende eksempel - de to giver samme resultat: Først fjerner vi kolonnen Cabin ved hjælp af select(), og derefter fjerner vi alle rækker, som har mindst én NA ved hjælp af drop_na(). titanic_clean &lt;- drop_na(select(titanic,-Cabin)) titanic_clean &lt;- titanic %&gt;% select(-Cabin) %&gt;% drop_na() 5.7 Bearbejdning af data: dplyr Pakken dplyr er nok den mest brugbare pakke til at bearbejde dataframes. Jeg gennemgår nogle af de mest almindelige muligheder med pakken, og der er også en “cheatsheet” som du kan downloade som reference: https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf. Jeg tager afsæt i følgende funktioner, og dækker flere gennem de forskellige øvelser og øvrige emner. dplyr verbs beskrivelse select() udvælge kolonner (variabler) filter() udvælge rækker (observationer) arrange() sortere rækker mutate() tilføje eller ændre eksisterende kolonner rename() ændre variablers navne recode() ændre selve data group_by() dele datasættet op efter en variabel summarise() aggregere rækker, findes ofte tilknyttet til group_by() Bemærk, at alle disse funktioner tager udgangspunkt i en dataframe, og man får altid en ny dataframe som output. Ved at kunne bruge disse funktioner og kombinere dem (ved hjælp af %&gt;%), har man godt styr på bearbejdningen af datarammer. 5.7.1 dplyr verbs: select() Som vi lige har set ovenfor, kan man med select() udvælge bestemte variabler i en dataframe. Vi kan vælge at beholde, fjerne eller ændre rækkefølgen af variablerne. Som et eksempel kan vi beholde kun variablerne Name og Age i titanic_clean-dataframen ved at bruge følgende kode: titanic_clean %&gt;% select(Name, Age) %&gt;% glimpse() ## Rows: 714 ## Columns: 2 ## $ Name &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Florence … ## $ Age &lt;dbl&gt; 22, 38, 26, 35, 35, 54, 2, 27, 14, 4, 58, 20, 39, 14, 55, 2, 31, … Hvis vi ønsker at fjerne en variabel fra en dataframe, kan vi bruge et minustegn. I nedenstående eksempel fjerner vi Name og Age fra titanic_clean-dataframen: titanic_clean %&gt;% select(-Name, -Age) %&gt;% glimpse() ## Rows: 714 ## Columns: 9 ## $ PassengerId &lt;int&gt; 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19… ## $ Survived &lt;int&gt; 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1… ## $ Pclass &lt;int&gt; 3, 1, 3, 1, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 3, 2, 2, 3… ## $ Sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;mal… ## $ SibSp &lt;int&gt; 1, 1, 0, 1, 0, 0, 3, 0, 1, 1, 0, 0, 1, 0, 0, 4, 1, 0, 0, 0… ## $ Parch &lt;int&gt; 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0… ## $ Ticket &lt;chr&gt; &quot;A/5 21171&quot;, &quot;PC 17599&quot;, &quot;STON/O2. 3101282&quot;, &quot;113803&quot;, &quot;37… ## $ Fare &lt;dbl&gt; 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 51.8625, 21.0750… ## $ Embarked &lt;chr&gt; &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;… 5.7.1.1 Hjælper funktioner til select() Hjælpefunktioner til funktionen select() kan være nyttige, hvis man vil udvælge bestemte variabler efter visse kriterier. Nedenfor har jeg samlet nogle (men ikke alle mulige!) hjælpefunktioner og inddrager eksempler i problemstillingerne. select hjælpefunktion beskrivelse starts_with() starter med et præfiks ends_with() slutter med et præfiks contains() indeholder en tekststreng matches() matcher et regulært udtryk num_range() et numerisk interval såsom x01, x02, x03 one_of() variabler i en karaktervektor everything() alle variabler where() tager en funktion og returnerer alle variabler, hvor funktionen returnerer TRUE For eksempel: titanic_clean %&gt;% select(starts_with(&quot;P&quot;)) ## # A tibble: 714 × 3 ## PassengerId Pclass Parch ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 3 0 ## 2 2 1 0 ## 3 3 3 0 ## 4 4 1 0 ## 5 5 3 0 ## 6 7 1 0 ## 7 8 3 1 ## 8 9 3 2 ## 9 10 2 0 ## 10 11 3 1 ## # … with 704 more rows Specielt brugbar i statistiske metoder, der kræver kun numeriske variabler, er where(), når den kombineres med is.numeric. For eksempel, i følgende kode udvælger man kun numeriske variabler fra datasættet titanic_clean: titanic_clean %&gt;% select(where(is.numeric)) ## # A tibble: 714 × 7 ## PassengerId Survived Pclass Age SibSp Parch Fare ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 0 3 22 1 0 7.25 ## 2 2 1 1 38 1 0 71.3 ## 3 3 1 3 26 0 0 7.92 ## 4 4 1 1 35 1 0 53.1 ## 5 5 0 3 35 0 0 8.05 ## 6 7 0 1 54 0 0 51.9 ## 7 8 0 3 2 3 1 21.1 ## 8 9 1 3 27 0 2 11.1 ## 9 10 1 2 14 1 0 30.1 ## 10 11 1 3 4 1 1 16.7 ## # … with 704 more rows 5.7.2 dplyr verbs: filter() Med funktionen select() udvælger man bestemte variabler. Til gengæld anvender man funktionen filter() til at udvælge bestemte observationer (rækker) fra en dataframe. I nedenstående eksempel beholder vi kun rækkerne, hvor variablen Age er lig med 50. Bemærk, at vi bevarer alle variabler i dataframe. titanic_clean %&gt;% filter(Age == 50) %&gt;% glimpse() ## Rows: 10 ## Columns: 11 ## $ PassengerId &lt;int&gt; 178, 260, 300, 435, 459, 483, 527, 545, 661, 724 ## $ Survived &lt;int&gt; 0, 1, 1, 0, 1, 0, 1, 0, 1, 0 ## $ Pclass &lt;int&gt; 1, 2, 1, 1, 2, 3, 2, 1, 1, 2 ## $ Name &lt;chr&gt; &quot;Isham, Miss. Ann Elizabeth&quot;, &quot;Parrish, Mrs. (Lutie Davis)… ## $ Sex &lt;chr&gt; &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;f… ## $ Age &lt;dbl&gt; 50, 50, 50, 50, 50, 50, 50, 50, 50, 50 ## $ SibSp &lt;int&gt; 0, 0, 0, 1, 0, 0, 0, 1, 2, 0 ## $ Parch &lt;int&gt; 0, 1, 1, 0, 0, 0, 0, 0, 0, 0 ## $ Ticket &lt;chr&gt; &quot;PC 17595&quot;, &quot;230433&quot;, &quot;PC 17558&quot;, &quot;13507&quot;, &quot;F.C.C. 13531&quot;,… ## $ Fare &lt;dbl&gt; 28.7125, 26.0000, 247.5208, 55.9000, 10.5000, 8.0500, 10.5… ## $ Embarked &lt;chr&gt; &quot;C&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot; Man kan også vælge intervallet af en variabel - for eksempel hvis man vil vælge alle, der er i halvtredserne. titanic_clean %&gt;% filter(Age &gt;= 50 &amp; Age &lt; 60) %&gt;% head() ## # A tibble: 6 × 11 ## PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Embar…¹ ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 7 0 1 &quot;McC… male 54 0 0 17463 51.9 S ## 2 12 1 1 &quot;Bon… fema… 58 0 0 113783 26.6 S ## 3 16 1 2 &quot;Hew… fema… 55 0 0 248706 16 S ## 4 95 0 3 &quot;Cox… male 59 0 0 364500 7.25 S ## 5 125 0 1 &quot;Whi… male 54 0 1 35281 77.3 S ## 6 151 0 2 &quot;Bat… male 51 0 0 S.O.P… 12.5 S ## # … with abbreviated variable name ¹​Embarked Man kan også kombinere betingelser fra forskellige kolonner, for eksempel i nedenstående eksempel vælger vi alle personer, som er kvinder og som rejste i første klasse. titanic_clean %&gt;% filter(Sex == &#39;female&#39; &amp; Pclass == 1) %&gt;% head() ## # A tibble: 6 × 11 ## PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Embar…¹ ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 1 1 Cumi… fema… 38 1 0 PC 17… 71.3 &quot;C&quot; ## 2 4 1 1 Futr… fema… 35 1 0 113803 53.1 &quot;S&quot; ## 3 12 1 1 Bonn… fema… 58 0 0 113783 26.6 &quot;S&quot; ## 4 53 1 1 Harp… fema… 49 1 0 PC 17… 76.7 &quot;C&quot; ## 5 62 1 1 Icar… fema… 38 0 0 113572 80 &quot;&quot; ## 6 89 1 1 Fort… fema… 23 3 2 19950 263 &quot;S&quot; ## # … with abbreviated variable name ¹​Embarked Vi kan også kombinere flere betingelser med forskellige symboler. For eksempel i nedenstående eksempel vælger vi personer, som er kvinder og som rejste i enten første eller anden klasse og som er i trediverne. Husk at tilføje runde parenteser omkring de to Pclass - prøv selv at fjerne dem og se, hvad der sker. titanic_clean %&gt;% filter(Sex == &#39;female&#39; &amp; (Pclass == 1 | Pclass == 2) &amp; Age %in% c(30:39)) %&gt;% glimpse() ## Rows: 43 ## Columns: 11 ## $ PassengerId &lt;int&gt; 2, 4, 62, 99, 191, 212, 216, 219, 231, 258, 259, 270, 310,… ## $ Survived &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1… ## $ Pclass &lt;int&gt; 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 2… ## $ Name &lt;chr&gt; &quot;Cumings, Mrs. John Bradley (Florence Briggs Thayer)&quot;, &quot;Fu… ## $ Sex &lt;chr&gt; &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;… ## $ Age &lt;dbl&gt; 38, 35, 38, 34, 32, 35, 31, 32, 35, 30, 35, 35, 30, 31, 30… ## $ SibSp &lt;int&gt; 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0… ## $ Parch &lt;int&gt; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0… ## $ Ticket &lt;chr&gt; &quot;PC 17599&quot;, &quot;113803&quot;, &quot;113572&quot;, &quot;231919&quot;, &quot;234604&quot;, &quot;F.C.C… ## $ Fare &lt;dbl&gt; 71.2833, 53.1000, 80.0000, 23.0000, 13.0000, 21.0000, 113.… ## $ Embarked &lt;chr&gt; &quot;C&quot;, &quot;S&quot;, &quot;&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;,… 5.7.3 Sammenligningsoperatorer Her er en tabel over sammenligningsoperatorer, som kan bruges i både filter() og i baseR (fordi konceptet bag er det samme, bare tilgangen er anderledes). Sammenligningsoperator Beskrivelse &lt; mindre end &gt; større end &lt;= mindre end eller lig med &gt;= større end eller lig med == lig med != forskellig fra &amp; og %in% inkluderet i | eller 5.7.4 Kombinere filter() og select() Man kan også kombinere både filter() og select() i samme kommando, som i følgende eksempel: titanic_clean %&gt;% filter(Sex == &#39;female&#39; &amp; (Pclass == 1 | Pclass == 2) &amp; Age %in% c(30:39)) %&gt;% select(Name, Fare) %&gt;% glimpse() ## Rows: 43 ## Columns: 2 ## $ Name &lt;chr&gt; &quot;Cumings, Mrs. John Bradley (Florence Briggs Thayer)&quot;, &quot;Futrelle,… ## $ Fare &lt;dbl&gt; 71.2833, 53.1000, 80.0000, 23.0000, 13.0000, 21.0000, 113.2750, 7… Bemærk at man skal være opmærksom på rækkefølgen, som man anvender de forskellige funktioner. Hvis man bytter rundt på filter() og select() i ovenstående eksempel, vil der opstå en advarsel. Prøv selv at køre følgende kode: ##virker ikke!!!!!##### titanic_clean %&gt;% select(Name, Fare) %&gt;% filter(Sex == &#39;female&#39; &amp; (Pclass == 1 | Pclass == 2) &amp; Age %in% c(30:39)) %&gt;% glimpse() Det skyldes, at hvis man først vælger at beholde variablerne Name og Age, så er de andre variabler ikke længere tilgængelige i den resulterende dataframe, som dernæst bruges i funktionen filter(). Derfor kan man ikke bruge funktionen filter() på variablerne Pclass,Sex og Age. 5.7.5 dplyr verbs: mutate() Man kan bruge funktionen mutate() til at tilføje en ny variabel til en dataframe. I nedenstående eksempel tilføjer jeg en ny variabel med navnet Adult, der angiver om personen kan betragtes som voksen (hvis vedkommende er mindst 18 år gammel). titanic_with_Adult &lt;- titanic_clean %&gt;% mutate(Adult = Age&gt;=18) titanic_with_Adult %&gt;% select(Adult) %&gt;% glimpse() ## Rows: 714 ## Columns: 1 ## $ Adult &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, T… Så kan man se, at der er 601 voksne og 113 børn som passagerere på skibet. Bemærk, at jeg gemmer resultatet som en ny dataframe, der hedder titanic_with_Adult, og derefter bruger jeg glimpse() på det nye objekt titanic_with_Adult for at se, hvordan min nye dataframe ser ud. I forudgående eksempler havde jeg ikke gemt resultatet - jeg havde bare brugt glimpse() for at se resultatet på skærmen. Hvis du gerne vil bruge din resulterende dataframe videre, så skal du huske at gemme den (ved brug af &lt;--tegnet). funktionen ifelse() indenfor mutate() Jeg kan oprette variablen Adult på en mere informativ måde end bare med TRUE eller FALSE. Jeg bruger funktionen ifelse(), som giver mulighed for at angive, at jeg gerne vil have teksten “adult”, hvis udsagnet Age&gt;=18 er sandt, og hvis det er falsk, vil jeg have teksten “child”: ifelse(Age&gt;=18,&quot;adult&quot;,&quot;child&quot;) Funktionen ifelse() bruges inden for mutate()-funktionen, fordi vi er i gang med at oprette en ny variabel, Adult - ifelse() giver os mulighed for at fortælle, hvordan den nye variabel skal se ud. titanic_clean %&gt;% mutate(Adult = ifelse(Age&gt;=18,&quot;adult&quot;,&quot;child&quot;)) %&gt;% select(Age,Adult) %&gt;% glimpse() ## Rows: 714 ## Columns: 2 ## $ Age &lt;dbl&gt; 22, 38, 26, 35, 35, 54, 2, 27, 14, 4, 58, 20, 39, 14, 55, 2, 31,… ## $ Adult &lt;chr&gt; &quot;adult&quot;, &quot;adult&quot;, &quot;adult&quot;, &quot;adult&quot;, &quot;adult&quot;, &quot;adult&quot;, &quot;child&quot;, &quot;… Så er variablen lidt mere informativ end før. Opret nye variabler ud fra andre variabler Man kan også oprette nye kolonner baseret på kombinationer af nogle af de eksisterende kolonner. For eksempel, lad os forestille os, at vi gerne vil have en ny kolonne, der viser summen af variablene Fare og Age, en der viser gennemsnittet af de to variabler, og en der hedder “Fare_per_year”. Det vises i følgende eksempel: titanic_clean %&gt;% mutate(&quot;Fare_Age_sum&quot; = Fare + Age, &quot;Fare_Age_mean&quot; = Fare_Age_sum / 2, &quot;Fare_per_year&quot; = Fare / Age) %&gt;% select(Age, Fare, Fare_Age_sum, Fare_Age_mean, Fare_per_year) %&gt;% glimpse() ## Rows: 714 ## Columns: 5 ## $ Age &lt;dbl&gt; 22, 38, 26, 35, 35, 54, 2, 27, 14, 4, 58, 20, 39, 14, 55… ## $ Fare &lt;dbl&gt; 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 51.8625, 21.07… ## $ Fare_Age_sum &lt;dbl&gt; 29.2500, 109.2833, 33.9250, 88.1000, 43.0500, 105.8625, … ## $ Fare_Age_mean &lt;dbl&gt; 14.62500, 54.64165, 16.96250, 44.05000, 21.52500, 52.931… ## $ Fare_per_year &lt;dbl&gt; 0.3295455, 1.8758763, 0.3048077, 1.5171429, 0.2300000, 0… Det er klart, at fortolkningen af Fare_Age_mean måske ikke er særlig interessant, men der ville være mange situationer, hvor man gerne vil kombinere kolonner for at lave en bestemt beregning. 5.7.6 rename() Man kan bruge rename() til at ændre navnet på en eller flere variable i datasættet. Som et eksempel bruger jeg rename() til at give en variabel navnet Years i stedet for Age (bemærk, at variablen Age ikke findes længere). titanic_clean %&gt;% rename(Years = Age) %&gt;% glimpse() ## Rows: 714 ## Columns: 11 ## $ PassengerId &lt;int&gt; 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19… ## $ Survived &lt;int&gt; 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1… ## $ Pclass &lt;int&gt; 3, 1, 3, 1, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 3, 2, 2, 3… ## $ Name &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Fl… ## $ Sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;mal… ## $ Years &lt;dbl&gt; 22, 38, 26, 35, 35, 54, 2, 27, 14, 4, 58, 20, 39, 14, 55, … ## $ SibSp &lt;int&gt; 1, 1, 0, 1, 0, 0, 3, 0, 1, 1, 0, 0, 1, 0, 0, 4, 1, 0, 0, 0… ## $ Parch &lt;int&gt; 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0… ## $ Ticket &lt;chr&gt; &quot;A/5 21171&quot;, &quot;PC 17599&quot;, &quot;STON/O2. 3101282&quot;, &quot;113803&quot;, &quot;37… ## $ Fare &lt;dbl&gt; 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 51.8625, 21.0750… ## $ Embarked &lt;chr&gt; &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;… Man kan også ændre navnene på flere kolonner på én gang. For eksempel i følgende kode laver jeg nogle oversættelsesarbejde: titanic_clean_dansk &lt;- titanic_clean %&gt;% rename(Overlevede = Survived, Navn = Name, Klasse = Pclass) Så du kan se, at jeg har ændret variablenes navne. Jeg kalder den nye dataframe for titanic_clean_dansk, så min danske version er blevet gemt et sted. Man kan også gøre sådan, at alle bogstaver i variablernes navne er små bogstaver. Jeg benytter den danske version, og jeg anvender rename_with() og specificerer tolower. titanic_clean_dansk %&gt;% rename_with(tolower) %&gt;% # alle variablernes navne er kun små bogstaver glimpse() ## Rows: 714 ## Columns: 11 ## $ passengerid &lt;int&gt; 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19… ## $ overlevede &lt;int&gt; 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1… ## $ klasse &lt;int&gt; 3, 1, 3, 1, 3, 1, 3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 3, 2, 2, 3… ## $ navn &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Fl… ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;mal… ## $ age &lt;dbl&gt; 22, 38, 26, 35, 35, 54, 2, 27, 14, 4, 58, 20, 39, 14, 55, … ## $ sibsp &lt;int&gt; 1, 1, 0, 1, 0, 0, 3, 0, 1, 1, 0, 0, 1, 0, 0, 4, 1, 0, 0, 0… ## $ parch &lt;int&gt; 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0… ## $ ticket &lt;chr&gt; &quot;A/5 21171&quot;, &quot;PC 17599&quot;, &quot;STON/O2. 3101282&quot;, &quot;113803&quot;, &quot;37… ## $ fare &lt;dbl&gt; 7.2500, 71.2833, 7.9250, 53.1000, 8.0500, 51.8625, 21.0750… ## $ embarked &lt;chr&gt; &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;… Prøv også at erstatte tolower med toupper. 5.7.7 dplyr verbs: recode() Med recode() kan man ændre hvordan en variable ser ud. For eksempel kan man ændre “male”/“female” til 0/1, som vist i følgende eksempel: titanic_clean %&gt;% mutate(Sex = recode(Sex, &quot;male&quot; = 0, &quot;female&quot; = 1)) %&gt;% select(PassengerId,Name,Sex) %&gt;% glimpse() ## Rows: 714 ## Columns: 3 ## $ PassengerId &lt;int&gt; 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19… ## $ Name &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Fl… ## $ Sex &lt;dbl&gt; 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1… Bemærk, at funktionen recode() er blevet brugt indenfor funktionen mutate(). Jeg lavede en ny variable af samme navn, men med ændret værdier indenfor variablen. Hvis man ønsker at ændre tilbage fra 0/1 til “male”/“female”, skal man skrive 1 / 0 for at specificere, at man har talværdier, og man ønsker at kalde dem for noget andet (“male”/“female” i dette tilfælde): #recodes variable Sex and then recodes it back to original form again titanic_clean %&gt;% mutate(Sex = recode(Sex, male = 1, female = 0)) %&gt;% mutate(Sex = recode(Sex, `1` = &quot;male&quot;, `0` = &quot;female&quot;)) %&gt;% #note use of `` in the numbers select(PassengerId,Name,Sex) %&gt;% glimpse() ## Rows: 714 ## Columns: 3 ## $ PassengerId &lt;int&gt; 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19… ## $ Name &lt;chr&gt; &quot;Braund, Mr. Owen Harris&quot;, &quot;Cumings, Mrs. John Bradley (Fl… ## $ Sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;mal… Bemærk brugen af `` i tallene. 5.7.8 dplyr verbs: arrange() Man anvender arrange() for at vælge rækkefølgen på observationerne. I nedenstående eksempel tager vi datarammen titanic_clean og arrangerer observationer efter variablen Fare. Det betyder, at personer, der har betalt mindst, vil være øverst i den resulterende dataramme, mens personer, der har betalt mest, vil være nederst. # Arrange by increasing Fare titanic_clean %&gt;% arrange(Fare) %&gt;% glimpse() ## Rows: 714 ## Columns: 11 ## $ PassengerId &lt;int&gt; 180, 264, 272, 303, 598, 807, 823, 379, 873, 327, 844, 819… ## $ Survived &lt;int&gt; 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0… ## $ Pclass &lt;int&gt; 3, 1, 3, 3, 3, 1, 1, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3… ## $ Name &lt;chr&gt; &quot;Leonard, Mr. Lionel&quot;, &quot;Harrison, Mr. William&quot;, &quot;Tornquist… ## $ Sex &lt;chr&gt; &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;m… ## $ Age &lt;dbl&gt; 36.0, 40.0, 25.0, 19.0, 49.0, 39.0, 38.0, 20.0, 33.0, 61.0… ## $ SibSp &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0… ## $ Parch &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ Ticket &lt;chr&gt; &quot;LINE&quot;, &quot;112059&quot;, &quot;LINE&quot;, &quot;LINE&quot;, &quot;LINE&quot;, &quot;112050&quot;, &quot;19972… ## $ Fare &lt;dbl&gt; 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 4.… ## $ Embarked &lt;chr&gt; &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;S&quot;… Hvis man gerne vil have det omvendt - at personer som har betalt mest, skal være øverst i datarammen, kan man bruge desc() omkring Fare, som i nedenstående: # Arrange by decreasing Fare titanic_clean %&gt;% arrange(desc(Fare)) %&gt;% glimpse() ## Rows: 714 ## Columns: 11 ## $ PassengerId &lt;int&gt; 259, 680, 738, 28, 89, 342, 439, 312, 743, 119, 300, 381, … ## $ Survived &lt;int&gt; 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1… ## $ Pclass &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ Name &lt;chr&gt; &quot;Ward, Miss. Anna&quot;, &quot;Cardeza, Mr. Thomas Drake Martinez&quot;, … ## $ Sex &lt;chr&gt; &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;mal… ## $ Age &lt;dbl&gt; 35.00, 36.00, 35.00, 19.00, 23.00, 24.00, 64.00, 18.00, 21… ## $ SibSp &lt;int&gt; 0, 0, 0, 3, 3, 3, 1, 2, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1… ## $ Parch &lt;int&gt; 0, 1, 0, 2, 2, 2, 4, 2, 2, 1, 1, 0, 0, 0, 2, 1, 0, 1, 2, 1… ## $ Ticket &lt;chr&gt; &quot;PC 17755&quot;, &quot;PC 17755&quot;, &quot;PC 17755&quot;, &quot;19950&quot;, &quot;19950&quot;, &quot;199… ## $ Fare &lt;dbl&gt; 512.3292, 512.3292, 512.3292, 263.0000, 263.0000, 263.0000… ## $ Embarked &lt;chr&gt; &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;… 5.8 Visualisering: bruge som input i ggplot2 Efter man har udført bearbejdning med tidyverse-kommandoer, kan man specificere den resulterende dataramme som data i funktionen ggplot(). Man benytter %&gt;%-operatoren til at forbinde dplyr-kommandoerne med ggplot-funktionen, og i dette tilfælde behøver man ikke at angive navnet på datarammen inde i ggplot-funktionen. I nedenstående eksempel tager jeg udgangspunkt i titanic_clean og laver et søjlediagram, som viser antallet af passagerer, der rejste i hver af de tre klasser. titanic_clean %&gt;% ggplot(aes(x=Pclass,fill=as.factor(Pclass))) + geom_bar(stat=&quot;count&quot;) + theme_minimal() Jeg gør det lidt mere kompliceret i følgende eksempel, hvor jeg tager udgangspunkt i titanic_clean, laver en ny kolonne kaldet Adult ved at bruge mutate(), og derefter bruger jeg den resulterende dataframe i ggplot() funktionen til at lave et plot, hvor jeg tæller antallet af voksne og børn: titanic_clean %&gt;% mutate(Adult = ifelse(Age&gt;=18,&quot;Adult&quot;,&quot;Child&quot;)) %&gt;% ggplot(aes(x=Adult,fill=Adult)) + geom_bar(stat=&quot;count&quot;) + theme_minimal() Så kan man se, at der var 600 voksne og lidt over 100 børn ombord på skibet. 5.9 Misc funktioner som er nyttige at vide 5.9.1 Pull I tidyverse arbejder vi meget med dataframes. Tilgangen er, at man tager udgangspunkt i en dataframe, får en dataframe som resultat, og så arbejder videre på den dataframe. Nogle gange kan det dog være, at man gerne vil udtrække en variabel som en vektor fra en dataframe, fx hvis man gerne vil bruge den i en bestemt statistisk metode. Her er et eksempel, hvor man udtrækker variablen Age for “male” og “female” (variablen Sex) og bruger de resulterende vektorer i en t-test: ages_male &lt;- titanic_clean %&gt;% filter(Sex==&quot;male&quot;) %&gt;% pull(Age) ages_female &lt;- titanic_clean %&gt;% filter(Sex==&quot;female&quot;) %&gt;% pull(Age) t.test(ages_male,ages_female) ## ## Welch Two Sample t-test ## ## data: ages_male and ages_female ## t = 2.5259, df = 560.05, p-value = 0.01181 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 0.6250732 4.9967983 ## sample estimates: ## mean of x mean of y ## 30.72664 27.91571 Så kan man se, at mænd og kvinder i gennemsnit har signifikant forskellige aldre (hvor mændene er ældre end kvinderne). 5.9.2 Slice Med funktionen slice kan man vælge specifikke observationer i en dataframe. Følgende eksempel viser de to passagerer, der har betalt mest for deres billet (variabeln Fare). titanic %&gt;% arrange(desc(Fare)) %&gt;% select(Name,Age) %&gt;% slice(1,2) ## # A tibble: 2 × 2 ## Name Age ## &lt;chr&gt; &lt;dbl&gt; ## 1 Ward, Miss. Anna 35 ## 2 Cardeza, Mr. Thomas Drake Martinez 36 Se udvidet muligheder her: https://dplyr.tidyverse.org/reference/slice.html 5.10 Problemstillinger Problem 1) Lav quizzen på Absalon - “Quiz - tidyverse - part 1” Vi øver os med datasættet Titanic. Indlæs datasættet og udfør den overstående oprydning med følgende kode: library(tidyverse) library(titanic) titanic &lt;- as_tibble(titanic_train) titanic_clean &lt;- titanic %&gt;% select(-Cabin) %&gt;% drop_na() %&gt;% mutate(Adult = ifelse(Age&gt;=18,&quot;adult&quot;,&quot;child&quot;)) %&gt;% mutate(Survived = recode(Survived, `1` = &quot;yes&quot;, `0` = &quot;no&quot;)) glimpse(titanic_clean) #take a look! Problem 2) select(). Tag udgangspunkt i titanic_clean og fjern variablen Name (du behøver ikke at gemme din nye dataframe). titanic_clean %&gt;% select(...) #redigere her Tilføj også glimpse() for at se et overblik (man kan også bruge head()) Problem 3) select(). Lav en ny dataframe ud fra titanic_clean med kun variabler Name, Pclass og Fare (du behøver ikke at gemme den). Gør det nogen forskel, i hvilken rækkefølge man skriver Name, Pclass og Fare? Problem 4) select() og hjælper funktioner. Tag udgangspunkt i titanic_clean. Hvad sker der, når man skriver starts_with(\"S\") i stedet for at specificere bestemte kolonnenavne inden for select()? Prøv også contains(\"ar\") Prøv også -any_of(c(\"Survived\",\"Pclass\",\"FavouriteColour\")) og -all_of(c(\"Survived\",\"Pclass\",\"FavouriteColour\")) Hvis man bruger all_of(), så skal alle variable i vektoren c(\"Survived\",\"Pclass\",\"FavouriteColour\") findes i datasættet, ellers vil man få en advarsel. Hvis man bruger any_of(), så vil alle variable fra vektoren c(\"Survived\",\"Pclass\",\"FavouriteColour\"), som findes i datasættet, blive inkluderet, mens de andre variable vil blive ignoreret. Prøv også matches(\"^S[i|u]\") - kan du gætte hvad det betyder (se nedenunder)? Problem 5) filter(). Opret en ny dataframe ud fra titanic_clean med alle passagerer, der er mellem 10 og 15 år gammel og har rejst i enten første eller anden klasse (du behøver ikke at gemme den). Prøv at tilføje %&gt;% count() til kommandoen - Hvor mange observationer er der i din nye dataframe? Problem 6) filter() og select() : kombinering med %&gt;% Opret en ny dataframe ud fra titanic_clean med alle passagerer, der er “male” og har overlevet (variablen Survived er “yes”), og vælg kun kolonnerne Name, Age og Fare. Problem 7) filter() og select() kombinering med %&gt;% Opret en ny dataframe ud fra titanic_clean med kun variabler Name og Age og dernæst specificere kun de passagerer som er over 60. Få du så den samme sæt observationer hvis du skriver dine select() og filter() funktionerne omvendt? Hvorfor? Problem 8) Mutate(). Ud fra titanic_clean opret en ny kolonne, som hedder FareRounded og viser Fare rundet til det nærmest integar (hint: benyt funktionen round()). Problem 9) Mutate(). Ud fra titanic_clean opret en ny kolonne, som hedder Mean_ID_Age og viser gennemsnittet af variablen PassengerId og variablen Age (se sektion Opret nye variabler ud fra andre variabler i kursusnotaterne hvis du er i tvivl). Problem 10) mutate() og ifelse(). Opret en ny dataramme ud fra titanic_clean med en ny kolon som hedder Family som angiver TRUE hvis Parch er ikke nul, ellers FALSE. Anvend funktionen-ifelse() til at gøre variablen mere intuitiv - “Family” og “Not family”. Problem 11) Mutate() og ifelse() Kig en gang til på beskrivelsen af følgende to variabler i datasættet: SibSp: The number of siblings/spouses aboard the titanic with the passenger Parch: The number of parents/children aboard the titanic with the passenger Tag udgangspunkt i titanic_clean og lav en ny variabel Solo, som viser “Ja”, hvis passageren rejste alene, og “Nej”, hvis passageren rejste med andre. Brug mutate() igen til at omdanne den nye variabel til en faktor. Gem også din nye dataframe, så du kan bruge din nye variabel videre i næste spørgsmål. titanic_clean &lt;- titanic_clean %&gt;% ... Problem 12) pull() og t.test() Betalt passagererne, der rejste alene (variablen Solo fra sidste opgave), i gennemsnit det samme for deres billet (variablen Fare) som passagererne, der ikke rejste alene? Lav en t-test (anvend filter() og så pull() til at udtrække to passende vektorer - se også eksempel i kursusnoterne). Problem 13) Recode() I variablen Embarked: C står for Cherbourg Q står for Queenstown S står for Southampton a) Anvend recode (indenfor mutate) til at ændre værdierne i variablen Embarked således at man får de fulde navne af de steder folk gik ombord skibet, i stedet for kun den første bogstav. Gem også dit output (som titanic_clean igen) så du kan bruge din nye variable videre. b) Erstat recode-funktionen med recode_factor-funktionen og sammenlign datatypen af variablen Embarked i din nye dataframe. c) Prøv at tilføje funktionen count() for at optælle hvor mange gik om bord i de forskellige steder. Prøv også med to variabler indenfor count() - Solo og Embarked Resultatet ser sådan ud: ## # A tibble: 7 × 3 ## Solo Embarked n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 No &quot;Southampton&quot; 229 ## 2 No &quot;Queenstown&quot; 9 ## 3 No &quot;Cherbourg&quot; 72 ## 4 Yes &quot;Southampton&quot; 325 ## 5 Yes &quot;Queenstown&quot; 19 ## 6 Yes &quot;Cherbourg&quot; 58 ## 7 Yes &quot;&quot; 2 d) Man kan se, at der er to passagerer hvor der ikke er noget skrevet i Embarked. + Rejste de alene? + Gem din dataframe med de to passagerer fjernet. Problem 14) Arrange(). Lav en ny dataramme ud fra titanic_clean med observationerne arrangerede således at de yngst er på toppen og ældste er på bunden. Kig på resultatet - hvad kan du fortælle om den yngste passager ombord skibet Titanic? Hvad kan du fortælle om den ældste passager ombord skibet? Overlevede de? Hvad med de andre ældste passagerer? Problem 15) Arrange() og kombinering med andre verber. Lav en ny dataramme fra titanic_clean med kun personer med SibSp&gt;0 og som gik ombord skibet i Southampton, arrangere de resulterende observationer efter Fare (højeste på toppen) og udvælg kun kolonnerne Name, Age og Fare. Problem 16) Rename(). Fra titanic_clean udvælg kun variabler Survived,Ticket, og Name og ændre deres navne til Overlevede, Billet og Navn. Gør variabler navne til store bogstaver ved at anvende rename_with(). Problem 17) Lave et plot. Fra titanic_clean bruge filter() til at lave en ny dataramme kun med personer under 30 og bruge den til at lave et barplot som viser antallet af personer opdelt efter Pclass. Bruge følgende struktur for koden: titanic_clean %&gt;% filter(...) %&gt;% #rediger linjen ggplot(aes(...)) + .... #tilføj plot Problem 18) Lave et plot. Fra titanic_clean, bruge mutate() til at lave et nyt kolon der hedder with_siblings_spouses der er TRUE hvis SibSp ikke er nul. Brug den til at lave boxplots som viser Fare på y-aksen og with_siblings_spouses på x-aksen. Ekstra: Ændre skalen på y-aksen for at gøre plottet klarer at fortolke. 5.11 Kommentarer matches(\"^S[i|u]\") betyder ^S variabel navn skal starter med en S [i|u] den næste bogstav i variabel navnet skal være enten i eller u OBS det er ikke vigtigt at lære pattern matching i kurset men det er meget brugbart i andre sammenhænge! Næste gange arbejder vi videre med tidyverse. Group_by kombinerede med Summarise Pivot_Longer/Pivot_Wider Join funktionerne "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
